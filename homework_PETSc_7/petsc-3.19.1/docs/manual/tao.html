
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>TAO: Optimization Solvers &#8212; PETSc 3.19.1 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../_static/styles/bootstrap.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=796348d33e8b1d947c94" rel="stylesheet">
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" />
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/katex-math.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94">
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/design-tabs.js"></script>
    <script src="../_static/katex.min.js"></script>
    <script src="../_static/auto-render.min.js"></script>
    <script src="../_static/katex_autorenderer.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'manual/tao';</script>
    <link rel="shortcut icon" href="../_static/petsc_favicon.png"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="DM: Interfacing Between Solvers and Models/Discretizations" href="dm.html" />
    <link rel="prev" title="TS: Scalable ODE and DAE Solvers" href="ts.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>

  
  <input type="checkbox" class="sidebar-toggle" name="__primary" id="__primary">
  <label class="overlay overlay-primary" for="__primary"></label>

  
  <input type="checkbox" class="sidebar-toggle" name="__secondary" id="__secondary">
  <label class="overlay overlay-secondary" for="__secondary"></label>

  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
      
<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
    </div>
  </div>

  
  <nav class="bd-header navbar navbar-expand-lg bd-navbar" id="navbar-main"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../index.html">

  
  
  
  
  
  
  

  
    <img src="../_static/PETSc-TAO_RGB.svg" class="logo__image only-light" alt="Logo image">
    <img src="../_static/PETSc-TAO_RGB_white.svg" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  
  <div class="col-lg-9 navbar-header-items">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="../overview/index.html">
                        Overview
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../install/index.html">
                        Install
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../tutorials/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="index.html">
                        User-Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../manualpages/index.html">
                        C/Fortran API
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../petsc4py/petsc4py.html">
                        Python API
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../faq/index.html">
                        FAQ
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../community/index.html">
                        Community
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../developers/index.html">
                        Developers
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../miscellaneous/index.html">
                        Misc.
                      </a>
                    </li>
                
    </ul>
</nav>
      </div>
      
    </div>

    <div id="navbar-end">
      
        <div class="navbar-end-item navbar-persistent--container">
          
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
        </div>
      
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://gitlab.com/petsc/petsc" title="GitLab" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fab fa-gitlab"></i></span>
            <label class="sr-only">GitLab</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>


  
  
    <div class="navbar-persistent--mobile">
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
    </div>
  

  
  <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
  </label>
  

</div>
  </nav>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item current active">
                      <a class="nav-link nav-internal" href="../overview/index.html">
                        Overview
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../install/index.html">
                        Install
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../tutorials/index.html">
                        Tutorials
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="index.html">
                        User-Guide
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../manualpages/index.html">
                        C/Fortran API
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../petsc4py/petsc4py.html">
                        Python API
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../faq/index.html">
                        FAQ
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../community/index.html">
                        Community
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../developers/index.html">
                        Developers
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../miscellaneous/index.html">
                        Misc.
                      </a>
                    </li>
                
    </ul>
</nav>
      </div>
      
      </div>
    

    
    
    <div class="sidebar-header-items__end">
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          <a href="https://gitlab.com/petsc/petsc" title="GitLab" class="nav-link" rel="noopener" target="_blank" data-toggle="tooltip"><span><i class="fab fa-gitlab"></i></span>
            <label class="sr-only">GitLab</label></a>
        </li>
      </ul>
      </div>
      
    </div>
    
  </div>

  
  <div class="sidebar-start-items sidebar-primary__section">
    <div class="sidebar-start-items__item"><nav class="bd-links" id="bd-docs-nav" aria-label="Section navigation">
  <p class="bd-links__title" role="heading" aria-level="1">
    Section Navigation
  </p>
  <div class="bd-toc-item navbar-nav">
    <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../overview/nutshell.html">PETSc in a nutshell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/features.html">Supported Systems</a></li>

<li class="toctree-l1"><a class="reference internal" href="../overview/gpu_roadmap.html">GPU Support Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/vector_table.html">Summary of Vector Types Available In PETSc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/matrix_table.html">Summary of Matrix Types Available In PETSc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/linear_solve_table.html">Summary of Sparse Linear Solvers Available In PETSc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/nonlinear_solve_table.html">Summary of Nonlinear Solvers Available In PETSc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/integrator_table.html">Summary of Time Integrators Available In PETSc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/tao_solve_table.html">Summary of Tao Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/discrete_table.html">Summary of Discretization Management Systems</a></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">User-Guide</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2 has-children"><a class="reference internal" href="introduction.html">Introduction to PETSc</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="about_this_manual.html">About This Manual</a></li>
<li class="toctree-l3"><a class="reference internal" href="getting_started.html">Getting Started</a></li>






</ul>
</li>
<li class="toctree-l2 current active has-children"><a class="reference internal" href="programming.html">The Solvers in PETSc/TAO</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="vec.html">Vectors and Parallel Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="mat.html">Matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="ksp.html">KSP: Linear System Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="snes.html">SNES: Nonlinear Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="ts.html">TS: Scalable ODE and DAE Solvers</a></li>

<li class="toctree-l3 current active"><a class="current reference internal" href="#">TAO: Optimization Solvers</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="dm.html">DM: Interfacing Between Solvers and Models/Discretizations</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="dmbase.html">DM Basics</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmplex.html">DMPlex: Unstructured Grids</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmstag.html">DMSTAG: Staggered, Structured Grid</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmnetwork.html">Networks</a></li>
<li class="toctree-l3"><a class="reference internal" href="dt.html">PetscDT: Discretization Technology in PETSc</a></li>
<li class="toctree-l3"><a class="reference internal" href="fe.html">PetscFE: Finite Element Infrastructure in PETSc</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="additional.html">Additional Information</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="fortran.html">PETSc for Fortran Users</a></li>
<li class="toctree-l3"><a class="reference internal" href="matlab.html">Using MATLAB with PETSc</a></li>
<li class="toctree-l3"><a class="reference internal" href="profiling.html">Profiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="performance.html">Hints for Performance Tuning</a></li>
<li class="toctree-l3"><a class="reference internal" href="blas-lapack.html">The Use of BLAS and LAPACK in PETSc and external libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="other.html">Other PETSc Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="advanced.html">Advanced Features of Matrices and Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="tests.html">Running PETSc Tests</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../manualpages/index.html">C/Fortran API</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/Vector.html">Vectors and Index Sets</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/Vec/index.html">Vector Operations (Vec)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/IS/index.html">Index sets (IS)</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/Matrix.html">Matrices and Matrix Operations</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/Mat/index.html">Matrix Operations (Mat)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/MatOrderings/index.html">Matrix colorings (MatColoring), orderings (MatOrdering), partitionings (MatPartitioning), and coarsening (MatCoarsen)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/MatFD/index.html">Finite difference computation of Jacobians (MatFD)</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/DataLayout.html">Data Layout and Communication</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/PetscSF/index.html">Star Forest Communication (PetscSF)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/PetscSection/index.html">Section Data Layout (PetscSection)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/AO/index.html">Application Orderings (AO)</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/DataManagement.html">Data Management between Vec and Mat, and Distributed Mesh Data Structures</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DM/index.html">Data Management (DM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DMDA/index.html">Structured Grids (DMDA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DMStag/index.html">Staggered, Structured Grids (DMSTAG)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DMPlex/index.html">Unstructured Grids and Cell Complexes (DMPLEX)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DMNetwork/index.html">Graphs and Networks (DMNETWORK)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DMForest/index.html">A Forest of Trees and Structured Adaptive Refinement (DMFOREST)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DMPatch/index.html">Sequences of parallel mesh patches (DMPATCH)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DMSwarm/index.html">Particle Discretizations (DMSWARM)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DMMOAB/index.html">MOAB Mesh Representation (DMMOAB)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DMLabel/index.html">Selecting Parts of Meshes (DMLabel)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DMPRODUCT/index.html">Tensor products of meshes (DMRODUCT)</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/Discretization.html">Discretization and Function Spaces</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DT/index.html">Discretization Technology and Quadrature (DT)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/SPACE/index.html">Function Spaces (PetscSpace)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/DUALSPACE/index.html">Dual Spaces (PetscDualSpace)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/FE/index.html">Finite Elements (PetscFE)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/FV/index.html">Finite Volumes (PetscFV)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/PF/index.html">Defining your own mathematical functions (PF)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/LANDAU/index.html">Landau Collision Operator</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/LinearSolvers.html">Linear Solvers and Preconditioners</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/KSP/index.html">Linear Solvers and Krylov Methods (KSP)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/PC/index.html">Preconditioners (PC)</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/NonlinearSolvers.html">Nonlinear Solvers</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-13"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/SNES/index.html">Nonlinear Solvers (SNES)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/SNESFAS/index.html">Full Approximation Scheme (FAS) nonlinear multigrid</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/Timestepping.html">Forward and Adjoint Timestepping</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-14"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/TS/index.html">Time Stepping ODE and DAE Solvers (TS)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/Sensitivity/index.html">Sensitivity Analysis for ODE and DAE</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/Characteristic/index.html">Semi-Lagrangian Solves using the Method of Characteristics</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/Optimization.html">Optimization</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-15"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/Tao/index.html">Optimization Solvers (Tao)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/TaoLineSearch/index.html">Optimization Line Search (TaoLineSearch)</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/Visualization.html">Graphics and Visualization</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-16"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/Draw/index.html">Graphics (Draw)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/Viewer/index.html">Viewing Objects (Viewer)</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../manualpages/System.html">System Routines, Profiling, Data Structures</a><input class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-17"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/Sys/index.html">PETSc Options, IO, and System Utilities</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/PetscH/index.html">Hash Tables</a></li>
<li class="toctree-l3"><a class="reference internal" href="../manualpages/Profiling/index.html">Profiling and Logging</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../changes/index.html">Changes for each release</a></li>
<li class="toctree-l2"><a class="reference internal" href="../manualpages/singleindex.html">Single Index of all PETSc Manual Pages</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changes/index.html">Changes for each release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../manualpages/singleindex.html">Single Index of all PETSc Manual Pages</a></li>
</ul>

  </div>
</nav>
    </div>
  </div>
  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

  
  <div id="rtd-footer-container"></div>

      </div>
      <main id="main-content" class="bd-main">
        
        
        <div class="bd-content">
          <div class="bd-article-container">
            
            <div class="bd-header-article">
                
            </div>
            
            
            <article class="bd-article" role="main">
              
  <section id="tao-optimization-solvers">
<span id="chapter-tao"></span><h1>TAO: Optimization Solvers<a class="headerlink" href="#tao-optimization-solvers" title="Permalink to this heading">#</a></h1>
<p>The Toolkit for Advanced Optimization (TAO) focuses on algorithms for the
solution of large-scale optimization problems on high-performance
architectures.  Methods are available for unconstrained, bound-constrained and
generally constrained optimization, nonlinear least squares problems,
variational inequalities and complementarity constraints.</p>
<section id="getting-started-a-simple-tao-example">
<span id="sec-tao-getting-started"></span><h2>Getting Started: A Simple TAO Example<a class="headerlink" href="#getting-started-a-simple-tao-example" title="Permalink to this heading">#</a></h2>
<p>To help the user start using TAO immediately, we introduce here a simple
uniprocessor example. Please read <a class="reference internal" href="#sec-tao-solvers"><span class="std std-ref">TAO Algorithms</span></a>
for a more in-depth discussion on using the TAO solvers. The code
presented <a class="reference internal" href="#tao-example1"><span class="std std-ref">below</span></a> minimizes the
extended Rosenbrock function <span class="math">\(f: \mathbb R^n \to \mathbb R\)</span>
defined by</p>
<div class="math">
\[f(x) = \sum_{i=0}^{m-1} \left( \alpha(x_{2i+1}-x_{2i}^2)^2 + (1-x_{2i})^2 \right),\]</div>
<p>where <span class="math">\(n = 2m\)</span> is the number of variables. Note that while we use
the C language to introduce the TAO software, the package is fully
usable from C++ and Fortran.
<a class="reference internal" href="fortran.html#chapter-fortran"><span class="std std-ref">PETSc for Fortran Users</span></a> discusses additional
issues concerning Fortran usage.</p>
<p>The code in <a class="reference internal" href="#tao-example1"><span class="std std-ref">the example</span></a> contains many of
the components needed to write most TAO programs and thus is
illustrative of the features present in complex optimization problems.
Note that for display purposes we have omitted some nonessential lines
of code as well as the (essential) code required for the routine
<code class="docutils literal notranslate"><span class="pre">FormFunctionGradient</span></code>, which evaluates the function and gradient, and
the code for <code class="docutils literal notranslate"><span class="pre">FormHessian</span></code>, which evaluates the Hessian matrix for
Rosenbrock’s function. The complete code is available in
<a class="reference external" href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/src/tao/unconstrained/tutorials/rosenbrock1.c.html">$TAO_DIR/src/unconstrained/tutorials/rosenbrock1.c</a>.
The following sections annotate the lines of code in
<a class="reference internal" href="#tao-example1"><span class="std std-ref">the example</span></a>.</p>
<div class="admonition-listing-src-tao-unconstrained-tutorials-rosenbrock1-c admonition" id="tao-example1">
<p class="admonition-title">Listing: <code class="docutils literal notranslate"><span class="pre">src/tao/unconstrained/tutorials/rosenbrock1.c</span></code></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;petsctao.h&gt;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscInt.html">PetscInt</a></span><span class="w">  </span><span class="n">n</span><span class="p">;</span><span class="w">     </span><span class="cm">/* dimension */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w"> </span><span class="n">alpha</span><span class="p">;</span><span class="w"> </span><span class="cm">/* condition parameter */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscBool.html">PetscBool</a></span><span class="w"> </span><span class="n">chained</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">AppCtx</span><span class="p">;</span>

<span class="cm">/* -------------- User-defined routines ---------- */</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">FormFunctionGradient</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">FormHessian</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w">   </span><span class="n">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w">         </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="cm">/* solution vector */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="w">         </span><span class="n">H</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w">         </span><span class="n">tao</span><span class="p">;</span><span class="w"> </span><span class="cm">/* <a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a> solver context */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscBool.html">PetscBool</a></span><span class="w">   </span><span class="n">flg</span><span class="p">,</span><span class="w"> </span><span class="n">test_lmvm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscBool.html">PETSC_FALSE</a></span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscMPIInt.html">PetscMPIInt</a></span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="cm">/* number of processes running */</span>
<span class="w">  </span><span class="n">AppCtx</span><span class="w">      </span><span class="n">user</span><span class="p">;</span><span class="w"> </span><span class="cm">/* user-defined application context */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/KSP/KSP.html">KSP</a></span><span class="w">         </span><span class="n">ksp</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/PC/PC.html">PC</a></span><span class="w">          </span><span class="n">pc</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="w">         </span><span class="n">M</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w">         </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">out2</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w">   </span><span class="n">mult_solve_dist</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* Initialize TAO and PETSc */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionBeginUser.html">PetscFunctionBeginUser</a></span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscInitialize.html">PetscInitialize</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argv</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">help</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCallMPI.html">PetscCallMPI</a></span><span class="p">(</span><span class="n"><a href="http://www.mpich.org/static/docs/latest/www3/MPI_Comm_size.html#MPI_Comm_size">MPI_Comm_size</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PETSC_COMM_WORLD.html">PETSC_COMM_WORLD</a></span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">size</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCheck.html">PetscCheck</a></span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PETSC_COMM_WORLD.html">PETSC_COMM_WORLD</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PETSC_ERR_WRONG_MPI_SIZE</a></span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Incorrect number of processors&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="cm">/* Initialize problem parameters */</span>
<span class="w">  </span><span class="n">user</span><span class="p">.</span><span class="n">n</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="n">user</span><span class="p">.</span><span class="n">alpha</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mf">99.0</span><span class="p">;</span>
<span class="w">  </span><span class="n">user</span><span class="p">.</span><span class="n">chained</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscBool.html">PETSC_FALSE</a></span><span class="p">;</span>
<span class="w">  </span><span class="cm">/* Check for command line arguments to override defaults */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscOptionsGetInt.html">PetscOptionsGetInt</a></span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-n&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">user</span><span class="p">.</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flg</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscOptionsGetReal.html">PetscOptionsGetReal</a></span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-alpha&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">user</span><span class="p">.</span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flg</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscOptionsGetBool.html">PetscOptionsGetBool</a></span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-chained&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">user</span><span class="p">.</span><span class="n">chained</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flg</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscOptionsGetBool.html">PetscOptionsGetBool</a></span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-test_lmvm&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">test_lmvm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flg</span><span class="p">));</span>

<span class="w">  </span><span class="cm">/* Allocate vectors for the solution and gradient */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecCreateSeq.html">VecCreateSeq</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PETSC_COMM_SELF.html">PETSC_COMM_SELF</a></span><span class="p">,</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatCreateSeqBAIJ.html">MatCreateSeqBAIJ</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PETSC_COMM_SELF.html">PETSC_COMM_SELF</a></span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">user</span><span class="p">.</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">H</span><span class="p">));</span>

<span class="w">  </span><span class="cm">/* The TAO code begins here */</span>

<span class="w">  </span><span class="cm">/* Create TAO solver with desired solution method */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoCreate.html">TaoCreate</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PETSC_COMM_SELF.html">PETSC_COMM_SELF</a></span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tao</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetType.html">TaoSetType</a></span><span class="p">(</span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAOLMVM.html">TAOLMVM</a></span><span class="p">));</span>

<span class="w">  </span><span class="cm">/* Set solution vec and an initial guess */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecSet.html">VecSet</a></span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetSolution.html">TaoSetSolution</a></span><span class="p">(</span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">));</span>

<span class="w">  </span><span class="cm">/* Set routines for function, gradient, hessian evaluation */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetObjectiveAndGradient.html">TaoSetObjectiveAndGradient</a></span><span class="p">(</span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">FormFunctionGradient</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">user</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetHessian.html">TaoSetHessian</a></span><span class="p">(</span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">FormHessian</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">user</span><span class="p">));</span>

<span class="w">  </span><span class="cm">/* Test the LMVM matrix */</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">test_lmvm</span><span class="p">)</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscOptionsSetValue.html">PetscOptionsSetValue</a></span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;-tao_type&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;bqnktr&quot;</span><span class="p">));</span>

<span class="w">  </span><span class="cm">/* Check for TAO command line options */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetFromOptions.html">TaoSetFromOptions</a></span><span class="p">(</span><span class="n">tao</span><span class="p">));</span>

<span class="w">  </span><span class="cm">/* SOLVE THE APPLICATION */</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a></span><span class="p">(</span><span class="n">tao</span><span class="p">));</span>

<span class="w">  </span><span class="cm">/* Test the LMVM matrix */</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">test_lmvm</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetKSP.html">TaoGetKSP</a></span><span class="p">(</span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ksp</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/KSP/KSPGetPC.html">KSPGetPC</a></span><span class="p">(</span><span class="n">ksp</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pc</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/PC/PCLMVMGetMatLMVM.html">PCLMVMGetMatLMVM</a></span><span class="p">(</span><span class="n">pc</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">M</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDuplicate.html">VecDuplicate</a></span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">in</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDuplicate.html">VecDuplicate</a></span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDuplicate.html">VecDuplicate</a></span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">out2</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecSet.html">VecSet</a></span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatMult.html">MatMult</a></span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatSolve.html">MatSolve</a></span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">out2</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecAXPY.html">VecAXPY</a></span><span class="p">(</span><span class="n">out2</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">,</span><span class="w"> </span><span class="n">in</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecNorm.html">VecNorm</a></span><span class="p">(</span><span class="n">out2</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/NORM_2.html">NORM_2</a></span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mult_solve_dist</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mult_solve_dist</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1.</span><span class="n">e</span><span class="mi">-11</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscPrintf.html">PetscPrintf</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscObjectComm.html">PetscObjectComm</a></span><span class="p">((</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscObject.html">PetscObject</a></span><span class="p">)</span><span class="n">tao</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;error between LMVM <a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatMult.html">MatMult</a> and <a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatSolve.html">MatSolve</a>: &lt; 1.e-11</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mult_solve_dist</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1.</span><span class="n">e</span><span class="mi">-6</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscPrintf.html">PetscPrintf</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscObjectComm.html">PetscObjectComm</a></span><span class="p">((</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscObject.html">PetscObject</a></span><span class="p">)</span><span class="n">tao</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;error between LMVM <a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatMult.html">MatMult</a> and <a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatSolve.html">MatSolve</a>: &lt; 1.e-6</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscPrintf.html">PetscPrintf</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscObjectComm.html">PetscObjectComm</a></span><span class="p">((</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscObject.html">PetscObject</a></span><span class="p">)</span><span class="n">tao</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;error between LMVM <a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatMult.html">MatMult</a> and <a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatSolve.html">MatSolve</a>: %e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">mult_solve_dist</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDestroy.html">VecDestroy</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">in</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDestroy.html">VecDestroy</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">out</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDestroy.html">VecDestroy</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">out2</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoDestroy.html">TaoDestroy</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">tao</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDestroy.html">VecDestroy</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatDestroy.html">MatDestroy</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">H</span><span class="p">));</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFinalize.html">PetscFinalize</a></span><span class="p">());</span>
<span class="k">return</span><span class="w"> </span><span class="n">ierr</span><span class="p">;}</span>
</pre></div>
</div>
</div>
</section>
<section id="tao-workflow">
<span id="sec-tao-workflow"></span><h2>TAO Workflow<a class="headerlink" href="#tao-workflow" title="Permalink to this heading">#</a></h2>
<p>Many TAO applications will follow an ordered set of procedures for
solving an optimization problem: The user creates a <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span></code> context and
selects a default algorithm. Call-back routines as well as vector
(<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span></code>) and matrix (<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span></code>) data structures are then set. These
call-back routines will be used for evaluating the objective function,
gradient, and perhaps the Hessian matrix. The user then invokes TAO to
solve the optimization problem and finally destroys the <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span></code> context.
A list of the necessary functions for performing these steps using TAO
is shown below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoCreate.html">TaoCreate</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/MPI_Comm.html">MPI_Comm</a></span><span class="w"> </span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="o">*</span><span class="n">tao</span><span class="p">);</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetType.html">TaoSetType</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoType.html">TaoType</a></span><span class="w"> </span><span class="n">type</span><span class="p">);</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetSolution.html">TaoSetSolution</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w"> </span><span class="n">x</span><span class="p">);</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetObjectiveAndGradient.html">TaoSetObjectiveAndGradient</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w"> </span><span class="n">g</span><span class="p">,</span>
<span class="w">     </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">FormFGradient</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="o">*</span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span>
<span class="w">     </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">user</span><span class="p">);</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetHessian.html">TaoSetHessian</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="w"> </span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="w"> </span><span class="n">Hpre</span><span class="p">,</span>
<span class="w">     </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">FormHessian</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span>
<span class="w">     </span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">user</span><span class="p">);</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">);</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoDestroy.html">TaoDestroy</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the solver algorithm selected through the function
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetType.html">TaoSetType</a>()</span></code> can be overridden at runtime by using an options
database. Through this database, the user not only can select a
minimization method (e.g., limited-memory variable metric, conjugate
gradient, Newton with line search or trust region) but also can
prescribe the convergence tolerance, set various monitoring routines,
set iterative methods and preconditions for solving the linear systems,
and so forth. See <a class="reference internal" href="#sec-tao-solvers"><span class="std std-ref">TAO Algorithms</span></a> for more
information on the solver methods available in TAO.</p>
<section id="header-file">
<h3>Header File<a class="headerlink" href="#header-file" title="Permalink to this heading">#</a></h3>
<p>TAO applications written in C/C++ should have the statement</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;petsctao.h&gt;</span>
</pre></div>
</div>
<p>in each file that uses a routine in the TAO libraries.</p>
</section>
<section id="creation-and-destruction">
<h3>Creation and Destruction<a class="headerlink" href="#creation-and-destruction" title="Permalink to this heading">#</a></h3>
<p>A TAO solver can be created by calling the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoCreate.html">TaoCreate</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/MPI_Comm.html">MPI_Comm</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>routine. Much like creating PETSc vector and matrix objects, the first
argument is an MPI <em>communicator</em>. An MPI <a class="footnote-reference brackets" href="#mpi" id="id1">1</a>
communicator indicates a collection of processors that will be used to
evaluate the objective function, compute constraints, and provide
derivative information. When only one processor is being used, the
communicator <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PETSC_COMM_SELF.html">PETSC_COMM_SELF</a></span></code> can be used with no understanding of
MPI. Even parallel users need to be familiar with only the basic
concepts of message passing and distributed-memory computing. Most
applications running TAO in parallel environments can employ the
communicator <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PETSC_COMM_WORLD.html">PETSC_COMM_WORLD</a></span></code> to indicate all processes known to
PETSc in a given run.</p>
<p>The routine</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetType.html">TaoSetType</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoType.html">TaoType</a></span><span class="p">);</span>
</pre></div>
</div>
<p>can be used to set the algorithm TAO uses to solve the application. The
various types of TAO solvers and the flags that identify them will be
discussed in the following sections. The solution method should be
carefully chosen depending on the problem being solved. Some solvers,
for instance, are meant for problems with no constraints, whereas other
solvers acknowledge constraints in the problem and handle them
accordingly. The user must also be aware of the derivative information
that is available. Some solvers require second-order information, while
other solvers require only gradient or function information. The command
line option <code class="docutils literal notranslate"><span class="pre">-tao_type</span></code> followed by
a TAO method will override any method specified by the second argument.
The command line option <code class="docutils literal notranslate"><span class="pre">-tao_type</span> <span class="pre">bqnls</span></code>, for instance, will
specify the limited-memory quasi-Newton line search method for
bound-constrained problems. Note that the <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoType.html">TaoType</a></span></code> variable is a string that
requires quotation marks in an application program, but quotation marks
are not required at the command line.</p>
<p>Each TAO solver that has been created should also be destroyed by using
the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoDestroy.html">TaoDestroy</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">);</span>
</pre></div>
</div>
<p>command. This routine frees the internal data structures used by the
solver.</p>
</section>
<section id="command-line-options">
<h3>Command-line Options<a class="headerlink" href="#command-line-options" title="Permalink to this heading">#</a></h3>
<p>Additional options for the TAO solver can be be set from the command
line by using the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetFromOptions.html">TaoSetFromOptions</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">)</span>
</pre></div>
</div>
<p>routine. This command also provides information about runtime options
when the user includes the <code class="docutils literal notranslate"><span class="pre">-help</span></code> option on the command line.</p>
<p>In addition to common command line options shared by all TAO solvers, each TAO
method also implements its own specialized options. Please refer to the
documentation for individual methods for more details.</p>
</section>
<section id="defining-variables">
<h3>Defining Variables<a class="headerlink" href="#defining-variables" title="Permalink to this heading">#</a></h3>
<p>In all the optimization solvers, the application must provide a <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span></code>
object of appropriate dimension to represent the variables. This vector
will be cloned by the solvers to create additional work space within the
solver. If this vector is distributed over multiple processors, it
should have a parallel distribution that allows for efficient scaling,
inner products, and function evaluations. This vector can be passed to
the application object by using the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetSolution.html">TaoSetSolution</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">);</span>
</pre></div>
</div>
<p>routine. When using this routine, the application should initialize the
vector with an approximate solution of the optimization problem before
calling the TAO solver. This vector will be used by the TAO solver to
store the solution. Elsewhere in the application, this solution vector
can be retrieved from the application object by using the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetSolution.html">TaoGetSolution</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>routine. This routine takes the address of a <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span></code> in the second
argument and sets it to the solution vector used in the application.</p>
</section>
<section id="user-defined-call-back-routines">
<h3>User Defined Call-back Routines<a class="headerlink" href="#user-defined-call-back-routines" title="Permalink to this heading">#</a></h3>
<p>Users of TAO are required to provide routines that perform function
evaluations. Depending on the solver chosen, they may also have to write
routines that evaluate the gradient vector and Hessian matrix.</p>
<section id="application-context">
<h4>Application Context<a class="headerlink" href="#application-context" title="Permalink to this heading">#</a></h4>
<p>Writing a TAO application may require use of an <em>application context</em>.
An application context is a structure or object defined by an
application developer, passed into a routine also written by the
application developer, and used within the routine to perform its stated
task.</p>
<p>For example, a routine that evaluates an objective function may need
parameters, work vectors, and other information. This information, which
may be specific to an application and necessary to evaluate the
objective, can be collected in a single structure and used as one of the
arguments in the routine. The address of this structure will be cast as
type <code class="docutils literal notranslate"><span class="pre">(void*)</span></code> and passed to the routine in the final argument. Many
examples of these structures are included in the TAO distribution.</p>
<p>This technique offers several advantages. In particular, it allows for a
uniform interface between TAO and the applications. The fundamental
information needed by TAO appears in the arguments of the routine, while
data specific to an application and its implementation is confined to an
opaque pointer. The routines can access information created outside the
local scope without the use of global variables. The TAO solvers and
application objects will never access this structure, so the application
developer has complete freedom to define it. If no such structure or
needed by the application then a NULL pointer can be used.</p>
</section>
<section id="objective-function-and-gradient-routines">
<span id="sec-fghj"></span><h4>Objective Function and Gradient Routines<a class="headerlink" href="#objective-function-and-gradient-routines" title="Permalink to this heading">#</a></h4>
<p>TAO solvers that minimize an objective function require the application
to evaluate the objective function. Some solvers may also require the
application to evaluate derivatives of the objective function. Routines
that perform these computations must be identified to the application
object and must follow a strict calling sequence.</p>
<p>Routines should follow the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EvaluateObjective</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>in order to evaluate an objective function
<span class="math">\(f: \, \mathbb R^n \to \mathbb R\)</span>. The first argument is the TAO
Solver object, the second argument is the <span class="math">\(n\)</span>-dimensional vector
that identifies where the objective should be evaluated, and the fourth
argument is an application context. This routine should use the third
argument to return the objective value evaluated at the point specified
by the vector in the second argument.</p>
<p>This routine, and the application context, should be passed to the
application object by using the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetObjective.html">TaoSetObjective</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="o">*</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>routine. The first argument in this routine is the TAO solver object,
the second argument is a function pointer to the routine that evaluates
the objective, and the third argument is the pointer to an appropriate
application context. Although the final argument may point to anything,
it must be cast as a <code class="docutils literal notranslate"><span class="pre">(void*)</span></code> type. This pointer will be passed back
to the developer in the fourth argument of the routine that evaluates
the objective. In this routine, the pointer can be cast back to the
appropriate type. Examples of these structures and their usage are
provided in the distribution.</p>
<p>Many TAO solvers also require gradient information from the application
The gradient of the objective function is specified in a similar manner.
Routines that evaluate the gradient should have the calling sequence</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EvaluateGradient</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>where the first argument is the TAO solver object, the second argument
is the variable vector, the third argument is the gradient vector, and
the fourth argument is the user-defined application context. Only the
third argument in this routine is different from the arguments in the
routine for evaluating the objective function. The numbers in the
gradient vector have no meaning when passed into this routine, but they
should represent the gradient of the objective at the specified point at
the end of the routine. This routine, and the user-defined pointer, can
be passed to the application object by using the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetGradient.html">TaoSetGradient</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>routine. In this routine, the first argument is the Tao object, the second
argument is the optional vector to hold the computed gradient, the
third argument is the function pointer, and the fourth object is the
application context, cast to <code class="docutils literal notranslate"><span class="pre">(void*)</span></code>.</p>
<p>Instead of evaluating the objective and its gradient in separate
routines, TAO also allows the user to evaluate the function and the
gradient in the same routine. In fact, some solvers are more efficient
when both function and gradient information can be computed in the same
routine. These routines should follow the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EvaluateFunctionAndGradient</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>where the first argument is the TAO solver and the second argument
points to the input vector for use in evaluating the function and
gradient. The third argument should return the function value, while the
fourth argument should return the gradient vector. The fifth argument is
a pointer to a user-defined context. This context and the name of the
routine should be set with the call</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetObjectiveAndGradient.html">TaoSetObjectiveAndGradient</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="o">*</span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>where the arguments are the TAO application, the optional vector to be
used to hold the computed gradient, a function pointer, and a
pointer to a user-defined context.</p>
<p>The TAO example problems demonstrate the use of these application
contexts as well as specific instances of function, gradient, and
Hessian evaluation routines. All these routines should return the
integer <span class="math">\(0\)</span> after successful completion and a nonzero integer if
the function is undefined at that point or an error occurred.</p>
</section>
<section id="hessian-evaluation">
<span id="sec-tao-matrixfree"></span><h4>Hessian Evaluation<a class="headerlink" href="#hessian-evaluation" title="Permalink to this heading">#</a></h4>
<p>Some optimization routines also require a Hessian matrix from the user.
The routine that evaluates the Hessian should have the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EvaluateHessian</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>where the first argument of this routine is a TAO solver object. The
second argument is the point at which the Hessian should be evaluated.
The third argument is the Hessian matrix, and the sixth argument is a
user-defined context. Since the Hessian matrix is usually used in
solving a system of linear equations, a preconditioner for the matrix is
often needed. The fourth argument is the matrix that will be used for
preconditioning the linear system; in most cases, this matrix will be
the same as the Hessian matrix. The fifth argument is the flag used to
set the Hessian matrix and linear solver in the routine
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/KSP/KSPSetOperators.html">KSPSetOperators</a>()</span></code>.</p>
<p>One can set the Hessian evaluation routine by calling the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetHessian.html">TaoSetHessian</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>routine. The first argument is the TAO Solver object. The second and
third arguments are, respectively, the Mat object where the Hessian will
be stored and the Mat object that will be used for the preconditioning
(they may be the same). The fourth argument is the function that
evaluates the Hessian, and the fifth argument is a pointer to a
user-defined context, cast to <code class="docutils literal notranslate"><span class="pre">(void*)</span></code>.</p>
<section id="finite-differences">
<h5>Finite Differences<a class="headerlink" href="#finite-differences" title="Permalink to this heading">#</a></h5>
<p>Finite-difference approximations can be used to compute the gradient and
the Hessian of an objective function. These approximations will slow the
solve considerably and are recommended primarily for checking the
accuracy of hand-coded gradients and Hessians. These routines are</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoDefaultComputeGradient.html">TaoDefaultComputeGradient</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoDefaultComputeHessian.html">TaoDefaultComputeHessian</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="o">*</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>respectively. They can be set by using <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetGradient.html">TaoSetGradient</a>()</span></code> and
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetHessian.html">TaoSetHessian</a>()</span></code> or through the options database with the
options <code class="docutils literal notranslate"><span class="pre">-tao_fdgrad</span></code> and <code class="docutils literal notranslate"><span class="pre">-tao_fd</span></code>, respectively.</p>
<p>The efficiency of the finite-difference Hessian can be improved if the
coloring of the matrix is known. If the application programmer creates a
PETSc <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatFDColoring.html">MatFDColoring</a></span></code> object, it can be applied to the
finite-difference approximation by setting the Hessian evaluation
routine to</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoDefaultComputeHessianColor.html">TaoDefaultComputeHessianColor</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>and using the <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatFDColoring.html">MatFDColoring</a></span></code> object as the last (<code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>) argument
to <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetHessian.html">TaoSetHessian</a>()</span></code>.</p>
<p>One also can use finite-difference approximations to directly check the
correctness of the gradient and/or Hessian evaluation routines. This
process can be initiated from the command line by using the special TAO
solver <code class="docutils literal notranslate"><span class="pre">tao_fd_test</span></code> together with the option <code class="docutils literal notranslate"><span class="pre">-tao_test_gradient</span></code>
or <code class="docutils literal notranslate"><span class="pre">-tao_test_hessian</span></code>.</p>
</section>
<section id="matrix-free-methods">
<h5>Matrix-Free Methods<a class="headerlink" href="#matrix-free-methods" title="Permalink to this heading">#</a></h5>
<p>TAO fully supports matrix-free methods. The matrices specified in the
Hessian evaluation routine need not be conventional matrices; instead,
they can point to the data required to implement a particular
matrix-free method. The matrix-free variant is allowed <em>only</em> when the
linear systems are solved by an iterative method in combination with no
preconditioning (<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/PC/PCNONE.html">PCNONE</a></span></code> or <code class="docutils literal notranslate"><span class="pre">-pc_type</span> <span class="pre">none</span></code>), a user-provided
preconditioner matrix, or a user-provided preconditioner shell
(<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/PC/PCSHELL.html">PCSHELL</a></span></code>). In other words, matrix-free methods cannot be used if a
direct solver is to be employed. Details about using matrix-free methods
are provided in the <a class="reference internal" href="index.html"><span class="doc">User-Guide</span></a>.</p>
<figure class="align-default" id="fig-taocallbacks">
<img alt="../_images/taofig.svg" src="../_images/taofig.svg" /><figcaption>
<p><span class="caption-number">Fig. 7 </span><span class="caption-text">Tao use of PETSc and callbacks</span><a class="headerlink" href="#fig-taocallbacks" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
</section>
<section id="constraints">
<span id="sec-bounds"></span><h4>Constraints<a class="headerlink" href="#constraints" title="Permalink to this heading">#</a></h4>
<p>Some optimization problems also impose constraints on the variables or
intermediate application states. The user defines these constraints through
the appropriate TAO interface functions and call-back routines where necessary.</p>
<section id="variable-bounds">
<h5>Variable Bounds<a class="headerlink" href="#variable-bounds" title="Permalink to this heading">#</a></h5>
<p>The simplest type of constraint on an optimization problem puts lower or
upper bounds on the variables. Vectors that represent lower and upper
bounds for each variable can be set with the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetVariableBounds.html">TaoSetVariableBounds</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">);</span>
</pre></div>
</div>
<p>command. The first vector and second vector should contain the lower and
upper bounds, respectively. When no upper or lower bound exists for a
variable, the bound may be set to <code class="docutils literal notranslate"><span class="pre">PETSC_INFINITY</span></code> or <code class="docutils literal notranslate"><span class="pre">PETSC_NINFINITY</span></code>.
After the two bound vectors have been set, they may be accessed with the
command <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetVariableBounds.html">TaoGetVariableBounds</a>()</span></code>.</p>
<p>Since not all solvers recognize the presence of bound constraints on
variables, the user must be careful to select a solver that acknowledges
these bounds.</p>
</section>
<section id="general-constraints">
<span id="sec-tao-programming"></span><h5>General Constraints<a class="headerlink" href="#general-constraints" title="Permalink to this heading">#</a></h5>
<p>Some TAO algorithms also support general constraints as a linear or nonlinear
function of the optimization variables. These constraints can be imposed either
as equalities or inequalities. TAO currently does not make any distinctions
between linear and nonlinear constraints, and implements them through the
same software interfaces.</p>
<p>In the equality constrained case, TAO assumes that the constraints are
formulated as <span class="math">\(c_e(x) = 0\)</span> and requires the user to implement a call-back
routine for evaluating <span class="math">\(c_e(x)\)</span> at a given vector of optimization
variables,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EvaluateEqualityConstraints</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>As in the previous call-back routines, the first argument is the TAO solver
object. The second and third arguments are the vector of optimization variables
(input) and vector of equality constraints (output), respectively. The final
argument is a pointer to the user-defined application context, cast into
<code class="docutils literal notranslate"><span class="pre">(void*)</span></code>.</p>
<p>Generally constrained TAO algorithms also require a second user call-back
function to compute the constraint Jacobian matrix <span class="math">\(\nabla_x c_e(x)\)</span>,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EvaluateEqualityJacobian</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>where the first and last arguments are the TAO solver object and the application
context pointer as before. The second argument is the vector of optimization
variables at which the computation takes place. The third and fourth arguments
are the constraint Jacobian and its pseudo-inverse (optional), respectively. The
pseudoinverse is optional, and if not available, the user can simply set it
to the constraint Jacobian itself.</p>
<p>These call-back functions are then given to the TAO solver using the
interface functions</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetEqualityConstraintsRoutine.html">TaoSetEqualityConstraintsRoutine</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetJacobianEqualityRoutine.html">TaoSetJacobianEqualityRoutine</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>Inequality constraints are assumed to be formulated as <span class="math">\(c_i(x) \leq 0\)</span>
and follow the same workflow as equality constraints using the
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetInequalityConstraintsRoutine.html">TaoSetInequalityConstraintsRoutine</a>()</span></code> and <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetJacobianInequalityRoutine.html">TaoSetJacobianInequalityRoutine</a>()</span></code>
interfaces.</p>
<p>Some TAO algorithms may adopt an alternative double-sided
<span class="math">\(c_l \leq c_i(x) \leq c_u\)</span> formulation and require the lower and upper
bounds <span class="math">\(c_l\)</span> and <span class="math">\(c_u\)</span> to be set using the
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetInequalityBounds.html">TaoSetInequalityBounds</a>(<a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a>,<a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a>,<a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a>)</span></code> interface. Please refer to the
documentation for each TAO algorithm for further details.</p>
</section>
</section>
</section>
<section id="solving">
<h3>Solving<a class="headerlink" href="#solving" title="Permalink to this heading">#</a></h3>
<p>Once the application and solver have been set up, the solver can be</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">);</span>
</pre></div>
</div>
<p>routine. We discuss several universal options below.</p>
<section id="convergence">
<span id="sec-customize"></span><h4>Convergence<a class="headerlink" href="#convergence" title="Permalink to this heading">#</a></h4>
<p>Although TAO and its solvers set default parameters that are useful for
many problems, the user may need to modify these parameters in order to
change the behavior and convergence of various algorithms.</p>
<p>One convergence criterion for most algorithms concerns the number of
digits of accuracy needed in the solution. In particular, the
convergence test employed by TAO attempts to stop when the error in the
constraints is less than <span class="math">\(\epsilon_{crtol}\)</span> and either</p>
<div class="math">
\[\begin{array}{lcl}
||g(X)|| &\leq& \epsilon_{gatol}, \\
||g(X)||/|f(X)| &\leq& \epsilon_{grtol}, \quad \text{or} \\
||g(X)||/|g(X_0)| &\leq& \epsilon_{gttol},
\end{array}\]</div>
<p>where <span class="math">\(X\)</span> is the current approximation to the true solution
<span class="math">\(X^*\)</span> and <span class="math">\(X_0\)</span> is the initial guess. <span class="math">\(X^*\)</span> is
unknown, so TAO estimates <span class="math">\(f(X) - f(X^*)\)</span> with either the square
of the norm of the gradient or the duality gap. A relative tolerance of
<span class="math">\(\epsilon_{frtol}=0.01\)</span> indicates that two significant digits are
desired in the objective function. Each solver sets its own convergence
tolerances, but they can be changed by using the routine
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetTolerances.html">TaoSetTolerances</a>()</span></code>. Another set of convergence tolerances terminates
the solver when the norm of the gradient function (or Lagrangian
function for bound-constrained problems) is sufficiently close to zero.</p>
<p>Other stopping criteria include a minimum trust-region radius or a
maximum number of iterations. These parameters can be set with the
routines <code class="docutils literal notranslate"><span class="pre">TaoSetTrustRegionTolerance()</span></code> and
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetMaximumIterations.html">TaoSetMaximumIterations</a>()</span></code> Similarly, a maximum number of function
evaluations can be set with the command
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetMaximumFunctionEvaluations.html">TaoSetMaximumFunctionEvaluations</a>()</span></code>. <code class="docutils literal notranslate"><span class="pre">-tao_max_it</span></code>, and
<code class="docutils literal notranslate"><span class="pre">-tao_max_funcs</span></code>.</p>
</section>
<section id="viewing-status">
<h4>Viewing Status<a class="headerlink" href="#viewing-status" title="Permalink to this heading">#</a></h4>
<p>To see parameters and performance statistics for the solver, the routine</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoView.html">TaoView</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">)</span>
</pre></div>
</div>
<p>can be used. This routine will display to standard output the number of
function evaluations need by the solver and other information specific
to the solver. This same output can be produced by using the command
line option <code class="docutils literal notranslate"><span class="pre">-tao_view</span></code>.</p>
<p>The progress of the optimization solver can be monitored with the
runtime option <code class="docutils literal notranslate"><span class="pre">-tao_monitor</span></code>. Although monitoring routines can be
customized, the default monitoring routine will print out several
relevant statistics to the screen.</p>
<p>The user also has access to information about the current solution. The
current iteration number, objective function value, gradient norm,
infeasibility norm, and step length can be retrieved with the following
command.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetSolutionStatus.html">TaoGetSolutionStatus</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscInt.html">PetscInt</a></span><span class="o">*</span><span class="w"> </span><span class="n">iterate</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="o">*</span><span class="w"> </span><span class="n">f</span><span class="p">,</span>
<span class="w">                  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="o">*</span><span class="w"> </span><span class="n">gnorm</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="o">*</span><span class="w"> </span><span class="n">cnorm</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="o">*</span><span class="w"> </span><span class="n">xdiff</span><span class="p">,</span>
<span class="w">                  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoConvergedReason.html">TaoConvergedReason</a></span><span class="o">*</span><span class="w"> </span><span class="n">reason</span><span class="p">)</span>
</pre></div>
</div>
<p>The last argument returns a code that indicates the reason that the
solver terminated. Positive numbers indicate that a solution has been
found, while negative numbers indicate a failure. A list of reasons can
be found in the manual page for <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetConvergedReason.html">TaoGetConvergedReason</a>()</span></code>.</p>
</section>
<section id="obtaining-a-solution">
<h4>Obtaining a Solution<a class="headerlink" href="#obtaining-a-solution" title="Permalink to this heading">#</a></h4>
<p>After exiting the <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a>()</span></code> function, the solution and the gradient can be
recovered with the following routines.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetSolution.html">TaoGetSolution</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="o">*</span><span class="p">);</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetGradient.html">TaoGetGradient</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span></code> returned by <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetSolution.html">TaoGetSolution</a>()</span></code> will be the
same vector passed to <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetSolution.html">TaoSetSolution</a>()</span></code>. This information can be
obtained during user-defined routines such as a function evaluation and
customized monitoring routine or after the solver has terminated.</p>
</section>
</section>
<section id="special-problem-structures">
<h3>Special Problem structures<a class="headerlink" href="#special-problem-structures" title="Permalink to this heading">#</a></h3>
<p>Certain special classes of problems solved with TAO utilize specialized
code interfaces that are described below per problem type.</p>
<section id="pde-constrained-optimization">
<h4>PDE-constrained Optimization<a class="headerlink" href="#pde-constrained-optimization" title="Permalink to this heading">#</a></h4>
<p>TAO solves PDE-constrained optimization problems of the form</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{u,v} & f(u,v) \\
\text{subject to} & g(u,v) = 0,
\end{array}\]</div>
<p>where the state variable <span class="math">\(u\)</span> is the solution to the discretized
partial differential equation defined by <span class="math">\(g\)</span> and parametrized by
the design variable <span class="math">\(v\)</span>, and <span class="math">\(f\)</span> is an objective function.
The Lagrange multipliers on the constraint are denoted by <span class="math">\(y\)</span>.
This method is set by using the linearly constrained augmented
Lagrangian TAO solver <code class="docutils literal notranslate"><span class="pre">tao_lcl</span></code>.</p>
<p>We make two main assumptions when solving these problems: the objective
function and PDE constraints have been discretized so that we can treat
the optimization problem as finite dimensional and
<span class="math">\(\nabla_u g(u,v)\)</span> is invertible for all <span class="math">\(u\)</span> and <span class="math">\(v\)</span>.</p>
<p>Unlike other TAO solvers where the solution vector contains only the
optimization variables, PDE-constrained problems solved with <code class="docutils literal notranslate"><span class="pre">tao_lcl</span></code>
combine the design and state variables together in a monolithic solution vector
<span class="math">\(x^T = [u^T, v^T]\)</span>. Consequently, the user must provide index sets to
separate the two,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetStateDesignIS.html">TaoSetStateDesignIS</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/IS/IS.html">IS</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/IS/IS.html">IS</a></span><span class="p">);</span>
</pre></div>
</div>
<p>where the first IS is a PETSc IndexSet containing the indices of the
state variables and the second IS the design variables.</p>
<p>PDE constraints have the general form <span class="math">\(g(x) = 0\)</span>,
where <span class="math">\(c: \mathbb R^n \to \mathbb R^m\)</span>. These constraints should
be specified in a routine, written by the user, that evaluates
<span class="math">\(g(x)\)</span>. The routine that evaluates the constraint equations
should have the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EvaluateConstraints</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>The first argument of this routine is a TAO solver object. The second
argument is the variable vector at which the constraint function should
be evaluated. The third argument is the vector of function values
<span class="math">\(g(x)\)</span>, and the fourth argument is a pointer to a user-defined
context. This routine and the user-defined context should be set in the
TAO solver with the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetConstraintsRoutine.html">TaoSetConstraintsRoutine</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>command. In this function, the first argument is the TAO solver object,
the second argument a vector in which to store the constraints, the
third argument is a function point to the routine for evaluating the
constraints, and the fourth argument is a pointer to a user-defined
context.</p>
<p>The Jacobian of <span class="math">\(g(x)\)</span> is the matrix in
<span class="math">\(\mathbb R^{m \times n}\)</span> such that each column contains the
partial derivatives of <span class="math">\(g(x)\)</span> with respect to one variable. The
evaluation of the Jacobian of <span class="math">\(g\)</span> should be performed by calling
the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">JacobianState</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">JacobianDesign</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>routines. In these functions, The first argument is the TAO solver
object. The second argument is the variable vector at which to evaluate
the Jacobian matrix, the third argument is the Jacobian matrix, and the
last argument is a pointer to a user-defined context. The fourth and
fifth arguments of the Jacobian evaluation with respect to the state
variables are for providing PETSc matrix objects for the preconditioner
and for applying the inverse of the state Jacobian, respectively. This
inverse matrix may be <code class="docutils literal notranslate"><span class="pre">PETSC_NULL</span></code>, in which case TAO will use a PETSc
Krylov subspace solver to solve the state system. These evaluation
routines should be registered with TAO by using the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetJacobianStateRoutine.html">TaoSetJacobianStateRoutine</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span>
<span class="w">                        </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span>
<span class="w">                        </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetJacobianDesignRoutine.html">TaoSetJacobianDesignRoutine</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span>
<span class="w">                        </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="o">*</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span>
<span class="w">                        </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>routines. The first argument is the TAO solver object, and the second
argument is the matrix in which the Jacobian information can be stored.
For the state Jacobian, the third argument is the matrix that will be
used for preconditioning, and the fourth argument is an optional matrix
for the inverse of the state Jacobian. One can use <code class="docutils literal notranslate"><span class="pre">PETSC_NULL</span></code> for
this inverse argument and let PETSc apply the inverse using a KSP
method, but faster results may be obtained by manipulating the structure
of the Jacobian and providing an inverse. The fifth argument is the
function pointer, and the sixth argument is an optional user-defined
context. Since no solve is performed with the design Jacobian, there is
no need to provide preconditioner or inverse matrices.</p>
</section>
<section id="nonlinear-least-squares">
<span id="sec-evalsof"></span><h4>Nonlinear Least Squares<a class="headerlink" href="#nonlinear-least-squares" title="Permalink to this heading">#</a></h4>
<p>For nonlinear least squares applications, we are solving the
optimization problem</p>
<div class="math">
\[\min_{x} \;\frac{1}{2}||r(x)||_2^2.

\]</div>
<p>For these problems, the objective function value should be computed as a
vector of residuals, <span class="math">\(r(x)\)</span>, computed with a function of the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EvaluateResidual</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>and set with the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetResidualRoutine.html">TaoSetResidualRoutine</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>routine. If required by the algorithm, the Jacobian of the residual,
<span class="math">\(J = \partial r(x) / \partial x\)</span>, should be computed with a
function of the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EvaluateJacobian</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>and set with the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetJacobianResidualRoutine.html">TaoSetJacobianResidualRoutine</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>routine.</p>
</section>
<section id="complementarity">
<h4>Complementarity<a class="headerlink" href="#complementarity" title="Permalink to this heading">#</a></h4>
<p>Complementarity applications have equality constraints in the form of
nonlinear equations <span class="math">\(C(X) = 0\)</span>, where
<span class="math">\(C: \mathbb R^n \to \mathbb R^m\)</span>. These constraints should be
specified in a routine written by the user with the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EqualityConstraints</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>that evaluates <span class="math">\(C(X)\)</span>. The first argument of this routine is a TAO
Solver object. The second argument is the variable vector <span class="math">\(X\)</span> at
which the constraint function should be evaluated. The third argument is
the output vector of function values <span class="math">\(C(X)\)</span>, and the fourth
argument is a pointer to a user-defined context.</p>
<p>This routine and the user-defined context must be registered with TAO by
using the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">TaoSetConstraintRoutine</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>command. In this command, the first argument is TAO Solver object, the
second argument is vector in which to store the function values, the
third argument is the user-defined routine that evaluates <span class="math">\(C(X)\)</span>,
and the fourth argument is a pointer to a user-defined context that will
be passed back to the user.</p>
<p>The Jacobian of the function is the matrix in
<span class="math">\(\mathbb R^{m \times n}\)</span> such that each column contains the
partial derivatives of <span class="math">\(f\)</span> with respect to one variable. The
evaluation of the Jacobian of <span class="math">\(C\)</span> should be performed in a routine
of the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">EvaluateJacobian</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>In this function, the first argument is the TAO Solver object and the
second argument is the variable vector at which to evaluate the Jacobian
matrix. The third argument is the Jacobian matrix, and the sixth
argument is a pointer to a user-defined context. Since the Jacobian
matrix may be used in solving a system of linear equations, a
preconditioner for the matrix may be needed. The fourth argument is the
matrix that will be used for preconditioning the linear system; in most
cases, this matrix will be the same as the Hessian matrix. The fifth
argument is the flag used to set the Jacobian matrix and linear solver
in the routine <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/KSP/KSPSetOperators.html">KSPSetOperators</a>()</span></code>.</p>
<p>This routine should be specified to TAO by using the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetJacobianRoutine.html">TaoSetJacobianRoutine</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>command. The first argument is the TAO Solver object; the second and
third arguments are the Mat objects in which the Jacobian will be stored
and the Mat object that will be used for the preconditioning (they may
be the same), respectively. The fourth argument is the function pointer;
and the fifth argument is an optional user-defined context. The Jacobian
matrix should be created in a way such that the product of it and the
variable vector can be stored in the constraint vector.</p>
</section>
</section>
</section>
<section id="tao-algorithms">
<span id="sec-tao-solvers"></span><h2>TAO Algorithms<a class="headerlink" href="#tao-algorithms" title="Permalink to this heading">#</a></h2>
<p>TAO includes a variety of optimization algorithms for several classes of
problems (unconstrained, bound-constrained, and PDE-constrained
minimization, nonlinear least-squares, and complementarity). The TAO
algorithms for solving these problems are detailed in this section, a
particular algorithm can chosen by using the <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetType.html">TaoSetType</a>()</span></code> function
or using the command line arguments <code class="docutils literal notranslate"><span class="pre">-tao_type</span> <span class="pre">&lt;name&gt;</span></code>. For those
interested in extending these algorithms or using new ones, please see
<a class="reference internal" href="#sec-tao-addsolver"><span class="std std-ref">Adding a Solver</span></a> for more information.</p>
<section id="unconstrained-minimization">
<span id="sec-tao-unconstrained"></span><h3>Unconstrained Minimization<a class="headerlink" href="#unconstrained-minimization" title="Permalink to this heading">#</a></h3>
<p>Unconstrained minimization is used to minimize a function of many
variables without any constraints on the variables, such as bounds. The
methods available in TAO for solving these problems can be classified
according to the amount of derivative information required:</p>
<ol class="arabic simple">
<li><p>Function evaluation only – Nelder-Mead method (<code class="docutils literal notranslate"><span class="pre">tao_nm</span></code>)</p></li>
<li><p>Function and gradient evaluations – limited-memory, variable-metric
method (<code class="docutils literal notranslate"><span class="pre">tao_lmvm</span></code>) and nonlinear conjugate gradient method
(<code class="docutils literal notranslate"><span class="pre">tao_cg</span></code>)</p></li>
<li><p>Function, gradient, and Hessian evaluations – Newton Krylov methods:
Netwon line search (<code class="docutils literal notranslate"><span class="pre">tao_nls</span></code>), Newton trust-region (<code class="docutils literal notranslate"><span class="pre">tao_ntr</span></code>),
and Newton trust-region line-search (<code class="docutils literal notranslate"><span class="pre">tao_ntl</span></code>)</p></li>
</ol>
<p>The best method to use depends on the particular problem being solved
and the accuracy required in the solution. If a Hessian evaluation
routine is available, then the Newton line search and Newton
trust-region methods will likely perform best. When a Hessian evaluation
routine is not available, then the limited-memory, variable-metric
method is likely to perform best. The Nelder-Mead method should be used
only as a last resort when no gradient information is available.</p>
<p>Each solver has a set of options associated with it that can be set with
command line arguments. These algorithms and the associated options are
briefly discussed in this section.</p>
<section id="newton-krylov-methods">
<h4>Newton-Krylov Methods<a class="headerlink" href="#newton-krylov-methods" title="Permalink to this heading">#</a></h4>
<p>TAO features three Newton-Krylov algorithms, separated by their globalization methods
for unconstrained optimization: line search (NLS), trust region (NTR), and trust
region with a line search (NTL). They are available via the TAO solvers
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAONLS.html">TAONLS</a></span></code>, <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAONTR.html">TAONTR</a></span></code> and <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAONTL.html">TAONTL</a></span></code>, respectively, or the <code class="docutils literal notranslate"><span class="pre">-tao_type</span></code>
<code class="docutils literal notranslate"><span class="pre">nls</span></code>/<code class="docutils literal notranslate"><span class="pre">ntr</span></code>/<code class="docutils literal notranslate"><span class="pre">ntl</span></code> flag.</p>
<section id="newton-line-search-method-nls">
<h5>Newton Line Search Method (NLS)<a class="headerlink" href="#newton-line-search-method-nls" title="Permalink to this heading">#</a></h5>
<p>The Newton line search method solves the symmetric system of equations</p>
<div class="math">
\[H_k d_k = -g_k

\]</div>
<p>to obtain a step <span class="math">\(d_k\)</span>, where <span class="math">\(H_k\)</span> is the Hessian of the
objective function at <span class="math">\(x_k\)</span> and <span class="math">\(g_k\)</span> is the gradient of the
objective function at <span class="math">\(x_k\)</span>. For problems where the Hessian matrix
is indefinite, the perturbed system of equations</p>
<div class="math">
\[(H_k + \rho_k I) d_k = -g_k

\]</div>
<p>is solved to obtain the direction, where <span class="math">\(\rho_k\)</span> is a positive
constant. If the direction computed is not a descent direction, the
(scaled) steepest descent direction is used instead. Having obtained the
direction, a Moré-Thuente line search is applied to obtain a step
length, <span class="math">\(\tau_k\)</span>, that approximately solves the one-dimensional
optimization problem</p>
<div class="math">
\[\min_\tau f(x_k + \tau d_k).

\]</div>
<p>The Newton line search method can be selected by using the TAO solver
<code class="docutils literal notranslate"><span class="pre">tao_nls</span></code>. The options available for this solver are listed in
<a class="reference internal" href="#table-nlsoptions"><span class="std std-numref">Table 18</span></a>. For the best efficiency, function and
gradient evaluations should be performed simultaneously when using this
algorithm.</p>
<blockquote>
<div><table class="docutils align-default" id="table-nlsoptions">
<caption><span class="caption-number">Table 18 </span><span class="caption-text">Summary of <code class="docutils literal notranslate"><span class="pre">nls</span></code> options</span><a class="headerlink" href="#table-nlsoptions" title="Permalink to this table">#</a></caption>
<colgroup>
<col style="width: 30%" />
<col style="width: 18%" />
<col style="width: 23%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_ksp_type</span></code></p></td>
<td><p>cg, nash,
stcg, gltr,
gmres, …</p></td>
<td><p>stcg</p></td>
<td><p>Type of Krylov
subspace
method to use
when solving
linear system</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_pc_type</span></code></p></td>
<td><p>none, jacobi,
icc, ilu, lmvm</p></td>
<td><p>lmvm</p></td>
<td><p>Type of
preconditioner
to use when
solving linear
system</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_sval</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(0\)</span></p></td>
<td><p>Initial
perturbation
value</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_imin</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(10^{-4}\)</span></p></td>
<td><p>Minimum
initial
perturbation
value</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_imax</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(100\)</span></p></td>
<td><p>Maximum
initial
perturbation
value</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_imfac</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(0.1\)</span></p></td>
<td><p>Factor applied
to norm of
gradient when
initializing
perturbation</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_pmax</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(100\)</span></p></td>
<td><p>Maximum
perturbation
when
increasing
value</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_pgfac</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(10\)</span></p></td>
<td><p>Growth factor
applied to
perturbation
when
increasing
value</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_pmgfac</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(0.1\)</span></p></td>
<td><p>Factor applied
to norm of
gradient when
increasing
perturbation</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_pmin</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(10^{-12}\)</span></p></td>
<td><p>Minimum
perturbation
when
decreasing
value; smaller
values set to
zero</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_psfac</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(0.4\)</span></p></td>
<td><p>Shrink factor
applied to
perturbation
when
decreasing
value</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_pmsfac</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(0.1\)</span></p></td>
<td><p>Factor applied
to norm of
gradient when
decreasing
perturbation</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_init_type</span></code></p></td>
<td><p>constant,
direction,
interpolation</p></td>
<td><p>interpolation</p></td>
<td><p>Method used to
initialize
trust-region
radius when
using
<code class="docutils literal notranslate"><span class="pre">nash</span></code>,
<code class="docutils literal notranslate"><span class="pre">stcg</span></code>, or
<code class="docutils literal notranslate"><span class="pre">gltr</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_mu1_i</span></code></p></td>
<td><p>real</p></td>
<td><p>0.35</p></td>
<td><p><span class="math">\(\mu_1\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_mu2_i</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\mu_2\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_gamma1_i</span></code></p></td>
<td><p>real</p></td>
<td><p>0.0625</p></td>
<td><p><span class="math">\(\gamma_1\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_gamma2_i</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\gamma_2\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_gamma3_i</span></code></p></td>
<td><p>real</p></td>
<td><p>2.00</p></td>
<td><p><span class="math">\(\gamma_3\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_gamma4_i</span></code></p></td>
<td><p>real</p></td>
<td><p>5.00</p></td>
<td><p><span class="math">\(\gamma_4\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_theta_i</span></code></p></td>
<td><p>real</p></td>
<td><p>0.25</p></td>
<td><p><span class="math">\(\theta\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_update_type</span></code></p></td>
<td><p>step,
reduction,
interpolation</p></td>
<td><p>step</p></td>
<td><p>Method used to
update
trust-region
radius when
using
<code class="docutils literal notranslate"><span class="pre">nash</span></code>,
<code class="docutils literal notranslate"><span class="pre">stcg</span></code>, or
<code class="docutils literal notranslate"><span class="pre">gltr</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_nu1</span></code></p></td>
<td><p>real</p></td>
<td><p>0.25</p></td>
<td><p><span class="math">\(\nu_1\)</span>
in <code class="docutils literal notranslate"><span class="pre">step</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_nu2</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\nu_2\)</span>
in <code class="docutils literal notranslate"><span class="pre">step</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_nu3</span></code></p></td>
<td><p>real</p></td>
<td><p>1.00</p></td>
<td><p><span class="math">\(\nu_3\)</span>
in <code class="docutils literal notranslate"><span class="pre">step</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_nu4</span></code></p></td>
<td><p>real</p></td>
<td><p>1.25</p></td>
<td><p><span class="math">\(\nu_4\)</span>
in <code class="docutils literal notranslate"><span class="pre">step</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_omega1</span></code></p></td>
<td><p>real</p></td>
<td><p>0.25</p></td>
<td><p><span class="math">\(\omega_1\)</span>
in <code class="docutils literal notranslate"><span class="pre">step</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_omega2</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\omega_2\)</span>
in <code class="docutils literal notranslate"><span class="pre">step</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_omega3</span></code></p></td>
<td><p>real</p></td>
<td><p>1.00</p></td>
<td><p><span class="math">\(\omega_3\)</span>
in <code class="docutils literal notranslate"><span class="pre">step</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_omega4</span></code></p></td>
<td><p>real</p></td>
<td><p>2.00</p></td>
<td><p><span class="math">\(\omega_4\)</span>
in <code class="docutils literal notranslate"><span class="pre">step</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_omega5</span></code></p></td>
<td><p>real</p></td>
<td><p>4.00</p></td>
<td><p><span class="math">\(\omega_5\)</span>
in <code class="docutils literal notranslate"><span class="pre">step</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_eta1</span></code></p></td>
<td><p>real</p></td>
<td><p><span class="math">\(10^{-4}\)</span></p></td>
<td><p><span class="math">\(\eta_1\)</span>
in
<code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_eta2</span></code></p></td>
<td><p>real</p></td>
<td><p>0.25</p></td>
<td><p><span class="math">\(\eta_2\)</span>
in
<code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_eta3</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\eta_3\)</span>
in
<code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_eta4</span></code></p></td>
<td><p>real</p></td>
<td><p>0.90</p></td>
<td><p><span class="math">\(\eta_4\)</span>
in
<code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_alpha1</span></code></p></td>
<td><p>real</p></td>
<td><p>0.25</p></td>
<td><p><span class="math">\(\alpha_1\)</span>
in
<code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_alpha2</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\alpha_2\)</span>
in
<code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_alpha3</span></code></p></td>
<td><p>real</p></td>
<td><p>1.00</p></td>
<td><p><span class="math">\(\alpha_3\)</span>
in
<code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_alpha4</span></code></p></td>
<td><p>real</p></td>
<td><p>2.00</p></td>
<td><p><span class="math">\(\alpha_4\)</span>
in
<code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_alpha5</span></code></p></td>
<td><p>real</p></td>
<td><p>4.00</p></td>
<td><p><span class="math">\(\alpha_5\)</span>
in
<code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_mu1</span></code></p></td>
<td><p>real</p></td>
<td><p>0.10</p></td>
<td><p><span class="math">\(\mu_1\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_mu2</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\mu_2\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_gamma1</span></code></p></td>
<td><p>real</p></td>
<td><p>0.25</p></td>
<td><p><span class="math">\(\gamma_1\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_gamma2</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\gamma_2\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_gamma3</span></code></p></td>
<td><p>real</p></td>
<td><p>2.00</p></td>
<td><p><span class="math">\(\gamma_3\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_gamma4</span></code></p></td>
<td><p>real</p></td>
<td><p>4.00</p></td>
<td><p><span class="math">\(\gamma_4\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_nls_theta</span></code></p></td>
<td><p>real</p></td>
<td><p>0.05</p></td>
<td><p><span class="math">\(\theta\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The system of equations is approximately solved by applying the
conjugate gradient method, Nash conjugate gradient method,
Steihaug-Toint conjugate gradient method, generalized Lanczos method, or
an alternative Krylov subspace method supplied by PETSc. The method used
to solve the systems of equations is specified with the command line
argument <code class="docutils literal notranslate"><span class="pre">-tao_nls_ksp_type</span> <span class="pre">&lt;cg,nash,stcg,gltr,gmres,...&gt;</span></code>; <code class="docutils literal notranslate"><span class="pre">stcg</span></code>
is the default. See the PETSc manual for further information on changing
the behavior of the linear system solvers.</p>
<p>A good preconditioner reduces the number of iterations required to solve
the linear system of equations. For the conjugate gradient methods and
generalized Lanczos method, this preconditioner must be symmetric and
positive definite. The available options are to use no preconditioner,
the absolute value of the diagonal of the Hessian matrix, a
limited-memory BFGS approximation to the Hessian matrix, or one of the
other preconditioners provided by the PETSc package. These
preconditioners are specified by the command line arguments
<code class="docutils literal notranslate"><span class="pre">-tao_nls_pc_type</span> <span class="pre">&lt;none,jacobi,icc,ilu,lmvm&gt;</span></code>, respectively. The
default is the <code class="docutils literal notranslate"><span class="pre">lmvm</span></code> preconditioner, which uses a BFGS approximation
of the inverse Hessian. See the PETSc manual for further information on
changing the behavior of the preconditioners.</p>
<p>The perturbation <span class="math">\(\rho_k\)</span> is added when the direction returned by
the Krylov subspace method is not a descent direction, the Krylov method
diverged due to an indefinite preconditioner or matrix, or a direction
of negative curvature was found. In the last two cases, if the step
returned is a descent direction, it is used during the line search.
Otherwise, a steepest descent direction is used during the line search.
The perturbation is decreased as long as the Krylov subspace method
reports success and increased if further problems are encountered. There
are three cases: initializing, increasing, and decreasing the
perturbation. These cases are described below.</p>
<ol class="arabic">
<li><p>If <span class="math">\(\rho_k\)</span> is zero and a problem was detected with either the
direction or the Krylov subspace method, the perturbation is
initialized to</p>
<div class="math">
\[\rho_{k+1} = \text{median}\left\{\text{imin}, \text{imfac} * \|g(x_k)\|, \text{imax}\right\},

\]</div>
<p>where <span class="math">\(g(x_k)\)</span> is the gradient of the objective function and
<code class="docutils literal notranslate"><span class="pre">imin</span></code> is set with the command line argument
<code class="docutils literal notranslate"><span class="pre">-tao_nls_imin</span> <span class="pre">&lt;real&gt;</span></code> with a default value of <span class="math">\(10^{-4}\)</span>,
<code class="docutils literal notranslate"><span class="pre">imfac</span></code> by <code class="docutils literal notranslate"><span class="pre">-tao_nls_imfac</span></code> with a default value of 0.1, and
<code class="docutils literal notranslate"><span class="pre">imax</span></code> by <code class="docutils literal notranslate"><span class="pre">-tao_nls_imax</span></code> with a default value of 100. When using
the <code class="docutils literal notranslate"><span class="pre">gltr</span></code> method to solve the system of equations, an estimate of
the minimum eigenvalue <span class="math">\(\lambda_1\)</span> of the Hessian matrix is
available. This value is used to initialize the perturbation to
<span class="math">\(\rho_{k+1} = \max\left\{\rho_{k+1}, -\lambda_1\right\}\)</span> in
this case.</p>
</li>
<li><p>If <span class="math">\(\rho_k\)</span> is nonzero and a problem was detected with either
the direction or Krylov subspace method, the perturbation is
increased to</p>
<div class="math">
\[\rho_{k+1} = \min\left\{\text{pmax}, \max\left\{\text{pgfac} * \rho_k, \text{pmgfac} * \|g(x_k)\|\right\}\right\},

\]</div>
<p>where <span class="math">\(g(x_k)\)</span> is the gradient of the objective function and
<code class="docutils literal notranslate"><span class="pre">pgfac</span></code> is set with the command line argument <code class="docutils literal notranslate"><span class="pre">-tao_nls_pgfac</span></code>
with a default value of 10, <code class="docutils literal notranslate"><span class="pre">pmgfac</span></code> by <code class="docutils literal notranslate"><span class="pre">-tao_nls_pmgfac</span></code> with a
default value of 0.1, and <code class="docutils literal notranslate"><span class="pre">pmax</span></code> by <code class="docutils literal notranslate"><span class="pre">-tao_nls_pmax</span></code> with a
default value of 100.</p>
</li>
<li><p>If <span class="math">\(\rho_k\)</span> is nonzero and no problems were detected with
either the direction or Krylov subspace method, the perturbation is
decreased to</p>
<div class="math">
\[\rho_{k+1} = \min\left\{\text{psfac} * \rho_k, \text{pmsfac} * \|g(x_k)\|\right\},

\]</div>
<p>where <span class="math">\(g(x_k)\)</span> is the gradient of the objective function,
<code class="docutils literal notranslate"><span class="pre">psfac</span></code> is set with the command line argument <code class="docutils literal notranslate"><span class="pre">-tao_nls_psfac</span></code>
with a default value of 0.4, and <code class="docutils literal notranslate"><span class="pre">pmsfac</span></code> is set by
<code class="docutils literal notranslate"><span class="pre">-tao_nls_pmsfac</span></code> with a default value of 0.1. Moreover, if
<span class="math">\(\rho_{k+1} &lt; \text{pmin}\)</span>, then <span class="math">\(\rho_{k+1} = 0\)</span>, where
<code class="docutils literal notranslate"><span class="pre">pmin</span></code> is set with the command line argument <code class="docutils literal notranslate"><span class="pre">-tao_nls_pmin</span></code> and
has a default value of <span class="math">\(10^{-12}\)</span>.</p>
</li>
</ol>
<p>Near a local minimizer to the unconstrained optimization problem, the
Hessian matrix will be positive-semidefinite; the perturbation will
shrink toward zero, and one would eventually observe a superlinear
convergence rate.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">nash</span></code>, <code class="docutils literal notranslate"><span class="pre">stcg</span></code>, or <code class="docutils literal notranslate"><span class="pre">gltr</span></code> to solve the linear systems
of equation, a trust-region radius needs to be initialized and updated.
This trust-region radius simultaneously limits the size of the step
computed and reduces the number of iterations of the conjugate gradient
method. The method for initializing the trust-region radius is set with
the command line argument
<code class="docutils literal notranslate"><span class="pre">-tao_nls_init_type</span> <span class="pre">&lt;constant,direction,interpolation&gt;</span></code>;
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>, which chooses an initial value based on the
interpolation scheme found in <span id="id2">[<a class="reference internal" href="#id2499" title="A. R. Conn, N. I. M. Gould, and Ph. L. Toint. Trust-Region Methods. SIAM, Philadelphia, Pennsylvania, 2000.">CGT00</a>]</span>, is the default.
This scheme performs a number of function and gradient evaluations to
determine a radius such that the reduction predicted by the quadratic
model along the gradient direction coincides with the actual reduction
in the nonlinear function. The iterate obtaining the best objective
function value is used as the starting point for the main line search
algorithm. The <code class="docutils literal notranslate"><span class="pre">constant</span></code> method initializes the trust-region radius
by using the value specified with the <code class="docutils literal notranslate"><span class="pre">-tao_trust0</span> <span class="pre">&lt;real&gt;</span></code> command
line argument, where the default value is 100. The <code class="docutils literal notranslate"><span class="pre">direction</span></code>
technique solves the first quadratic optimization problem by using a
standard conjugate gradient method and initializes the trust region to
<span class="math">\(\|s_0\|\)</span>.</p>
<p>The method for updating the trust-region radius is set with the command
line argument <code class="docutils literal notranslate"><span class="pre">-tao_nls_update_type</span> <span class="pre">&lt;step,reduction,interpolation&gt;</span></code>;
<code class="docutils literal notranslate"><span class="pre">step</span></code> is the default. The <code class="docutils literal notranslate"><span class="pre">step</span></code> method updates the trust-region
radius based on the value of <span class="math">\(\tau_k\)</span>. In particular,</p>
<div class="math">
\[\Delta_{k+1} = \left\{\begin{array}{ll}
\omega_1 \text{min}(\Delta_k, \|d_k\|) & \text{if } \tau_k \in [0, \nu_1) \\
\omega_2 \text{min}(\Delta_k, \|d_k\|) & \text{if } \tau_k \in [\nu_1, \nu_2) \\
\omega_3 \Delta_k & \text{if } \tau_k \in [\nu_2, \nu_3) \\
\text{max}(\Delta_k, \omega_4 \|d_k\|) & \text{if } \tau_k \in [\nu_3, \nu_4) \\
\text{max}(\Delta_k, \omega_5 \|d_k\|) & \text{if } \tau_k \in [\nu_4, \infty),
\end{array}
\right.\]</div>
<p>where
<span class="math">\(0 &lt; \omega_1 &lt; \omega_2 &lt; \omega_3 = 1 &lt; \omega_4 &lt; \omega_5\)</span> and
<span class="math">\(0 &lt; \nu_1 &lt; \nu_2 &lt; \nu_3 &lt; \nu_4\)</span> are constants. The
<code class="docutils literal notranslate"><span class="pre">reduction</span></code> method computes the ratio of the actual reduction in the
objective function to the reduction predicted by the quadratic model for
the full step,
<span class="math">\(\kappa_k = \frac{f(x_k) - f(x_k + d_k)}{q(x_k) - q(x_k + d_k)}\)</span>,
where <span class="math">\(q_k\)</span> is the quadratic model. The radius is then updated as</p>
<div class="math">
\[\Delta_{k+1} = \left\{\begin{array}{ll}
\alpha_1 \text{min}(\Delta_k, \|d_k\|) & \text{if } \kappa_k \in (-\infty, \eta_1) \\
\alpha_2 \text{min}(\Delta_k, \|d_k\|) & \text{if } \kappa_k \in [\eta_1, \eta_2) \\
\alpha_3 \Delta_k & \text{if } \kappa_k \in [\eta_2, \eta_3) \\
\text{max}(\Delta_k, \alpha_4 \|d_k\|) & \text{if } \kappa_k \in [\eta_3, \eta_4) \\
\text{max}(\Delta_k, \alpha_5 \|d_k\|) & \text{if } \kappa_k \in [\eta_4, \infty),
\end{array}
\right.\]</div>
<p>where
<span class="math">\(0 &lt; \alpha_1 &lt; \alpha_2 &lt; \alpha_3 = 1 &lt; \alpha_4 &lt; \alpha_5\)</span> and
<span class="math">\(0 &lt; \eta_1 &lt; \eta_2 &lt; \eta_3 &lt; \eta_4\)</span> are constants. The
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code> method uses the same interpolation mechanism as in the
initialization to compute a new value for the trust-region radius.</p>
<p>This algorithm will be deprecated in the next version and replaced by
the Bounded Newton Line Search (BNLS) algorithm that can solve both
bound constrained and unconstrained problems.</p>
</section>
<section id="newton-trust-region-method-ntr">
<h5>Newton Trust-Region Method (NTR)<a class="headerlink" href="#newton-trust-region-method-ntr" title="Permalink to this heading">#</a></h5>
<p>The Newton trust-region method solves the constrained quadratic
programming problem</p>
<div class="math">
\[\begin{array}{ll}
\min_d  & \frac{1}{2}d^T H_k d  + g_k^T d \\
\text{subject to} & \|d\| \leq \Delta_k
\end{array}\]</div>
<p>to obtain a direction <span class="math">\(d_k\)</span>, where <span class="math">\(H_k\)</span> is the Hessian of
the objective function at <span class="math">\(x_k\)</span>, <span class="math">\(g_k\)</span> is the gradient of
the objective function at <span class="math">\(x_k\)</span>, and <span class="math">\(\Delta_k\)</span> is the
trust-region radius. If <span class="math">\(x_k + d_k\)</span> sufficiently reduces the
nonlinear objective function, then the step is accepted, and the
trust-region radius is updated. However, if <span class="math">\(x_k + d_k\)</span> does not
sufficiently reduce the nonlinear objective function, then the step is
rejected, the trust-region radius is reduced, and the quadratic program
is re-solved by using the updated trust-region radius. The Newton
trust-region method can be set by using the TAO solver <code class="docutils literal notranslate"><span class="pre">tao_ntr</span></code>. The
options available for this solver are listed in
<a class="reference internal" href="#table-ntroptions"><span class="std std-numref">Table 19</span></a>. For the best efficiency, function and
gradient evaluations should be performed separately when using this
algorithm.</p>
<blockquote>
<div><table class="docutils align-default" id="table-ntroptions">
<caption><span class="caption-number">Table 19 </span><span class="caption-text">Summary of <code class="docutils literal notranslate"><span class="pre">ntr</span></code> options</span><a class="headerlink" href="#table-ntroptions" title="Permalink to this table">#</a></caption>
<colgroup>
<col style="width: 33%" />
<col style="width: 19%" />
<col style="width: 22%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Name</p></th>
<th class="head"><p>Value</p></th>
<th class="head"><p>Default</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_ksp_type</span></code></p></td>
<td><p>nash, stcg,
gltr</p></td>
<td><p>stcg</p></td>
<td><p>Type of Krylov
subspace
method to use
when solving
linear system</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_pc_type</span></code></p></td>
<td><p>none, jacobi,
icc, ilu, lmvm</p></td>
<td><p>lmvm</p></td>
<td><p>Type of
preconditioner
to use when
solving linear
system</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_init_type</span></code></p></td>
<td><p>constant,
direction,
interpolation</p></td>
<td><p>interpolation</p></td>
<td><p>Method used to
initialize
trust-region
radius</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_mu1_i</span></code></p></td>
<td><p>real</p></td>
<td><p>0.35</p></td>
<td><p><span class="math">\(\mu_1\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_mu2_i</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\mu_2\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_gamma1_i</span></code></p></td>
<td><p>real</p></td>
<td><p>0.0625</p></td>
<td><p><span class="math">\(\gamma_1\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_gamma2_i</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\gamma_2\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_gamma3_i</span></code></p></td>
<td><p>real</p></td>
<td><p>2.00</p></td>
<td><p><span class="math">\(\gamma_3\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_gamma4_i</span></code></p></td>
<td><p>real</p></td>
<td><p>5.00</p></td>
<td><p><span class="math">\(\gamma_4\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_theta_i</span></code></p></td>
<td><p>real</p></td>
<td><p>0.25</p></td>
<td><p><span class="math">\(\theta\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
init</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_update_type</span></code></p></td>
<td><p>reduction,
interpolation</p></td>
<td><p>reduction</p></td>
<td><p>Method used to
update
trust-region
radius</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_eta1</span></code></p></td>
<td><p>real</p></td>
<td><p>:</p></td>
<td><p><span class="math">\(\eta_1\)</span>
in <code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_eta2</span></code></p></td>
<td><p>real</p></td>
<td><p>0.25</p></td>
<td><p><span class="math">\(\eta_2\)</span>
in <code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_eta3</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\eta_3\)</span>
in <code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_eta4</span></code></p></td>
<td><p>real</p></td>
<td><p>0.90</p></td>
<td><p><span class="math">\(\eta_4\)</span>
in <code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_alpha1</span></code></p></td>
<td><p>real</p></td>
<td><p>0.25</p></td>
<td><p><span class="math">\(\alpha_1\)</span>
in <code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_alpha2</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\alpha_2\)</span>
in <code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_alpha3</span></code></p></td>
<td><p>real</p></td>
<td><p>1.00</p></td>
<td><p><span class="math">\(\alpha_3\)</span>
in <code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_alpha4</span></code></p></td>
<td><p>real</p></td>
<td><p>2.00</p></td>
<td><p><span class="math">\(\alpha_4\)</span>
in <code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_alpha5</span></code></p></td>
<td><p>real</p></td>
<td><p>4.00</p></td>
<td><p><span class="math">\(\alpha_5\)</span>
in <code class="docutils literal notranslate"><span class="pre">reduction</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_mu1</span></code></p></td>
<td><p>real</p></td>
<td><p>0.10</p></td>
<td><p><span class="math">\(\mu_1\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_mu2</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\mu_2\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_gamma1</span></code></p></td>
<td><p>real</p></td>
<td><p>0.25</p></td>
<td><p><span class="math">\(\gamma_1\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_gamma2</span></code></p></td>
<td><p>real</p></td>
<td><p>0.50</p></td>
<td><p><span class="math">\(\gamma_2\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_gamma3</span></code></p></td>
<td><p>real</p></td>
<td><p>2.00</p></td>
<td><p><span class="math">\(\gamma_3\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_gamma4</span></code></p></td>
<td><p>real</p></td>
<td><p>4.00</p></td>
<td><p><span class="math">\(\gamma_4\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">-tao_ntr_theta</span></code></p></td>
<td><p>real</p></td>
<td><p>0.05</p></td>
<td><p><span class="math">\(\theta\)</span>
in
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>
update</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>The quadratic optimization problem is approximately solved by applying
the Nash or Steihaug-Toint conjugate gradient methods or the generalized
Lanczos method to the symmetric system of equations
<span class="math">\(H_k d = -g_k\)</span>. The method used to solve the system of equations
is specified with the command line argument
<code class="docutils literal notranslate"><span class="pre">-tao_ntr_ksp_type</span> <span class="pre">&lt;nash,stcg,gltr&gt;</span></code>; <code class="docutils literal notranslate"><span class="pre">stcg</span></code> is the default. See the
PETSc manual for further information on changing the behavior of these
linear system solvers.</p>
<p>A good preconditioner reduces the number of iterations required to
compute the direction. For the Nash and Steihaug-Toint conjugate
gradient methods and generalized Lanczos method, this preconditioner
must be symmetric and positive definite. The available options are to
use no preconditioner, the absolute value of the diagonal of the Hessian
matrix, a limited-memory BFGS approximation to the Hessian matrix, or
one of the other preconditioners provided by the PETSc package. These
preconditioners are specified by the command line argument
<code class="docutils literal notranslate"><span class="pre">-tao_ntr_pc_type</span> <span class="pre">&lt;none,jacobi,icc,ilu,lmvm&gt;</span></code>, respectively. The
default is the <code class="docutils literal notranslate"><span class="pre">lmvm</span></code> preconditioner. See the PETSc manual for further
information on changing the behavior of the preconditioners.</p>
<p>The method for computing an initial trust-region radius is set with the
command line arguments
<code class="docutils literal notranslate"><span class="pre">-tao_ntr_init_type</span> <span class="pre">&lt;constant,direction,interpolation&gt;</span></code>;
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code>, which chooses an initial value based on the
interpolation scheme found in <span id="id3">[<a class="reference internal" href="#id2499" title="A. R. Conn, N. I. M. Gould, and Ph. L. Toint. Trust-Region Methods. SIAM, Philadelphia, Pennsylvania, 2000.">CGT00</a>]</span>, is the default.
This scheme performs a number of function and gradient evaluations to
determine a radius such that the reduction predicted by the quadratic
model along the gradient direction coincides with the actual reduction
in the nonlinear function. The iterate obtaining the best objective
function value is used as the starting point for the main trust-region
algorithm. The <code class="docutils literal notranslate"><span class="pre">constant</span></code> method initializes the trust-region radius
by using the value specified with the <code class="docutils literal notranslate"><span class="pre">-tao_trust0</span> <span class="pre">&lt;real&gt;</span></code> command
line argument, where the default value is 100. The <code class="docutils literal notranslate"><span class="pre">direction</span></code>
technique solves the first quadratic optimization problem by using a
standard conjugate gradient method and initializes the trust region to
<span class="math">\(\|s_0\|\)</span>.</p>
<p>The method for updating the trust-region radius is set with the command
line arguments <code class="docutils literal notranslate"><span class="pre">-tao_ntr_update_type</span> <span class="pre">&lt;reduction,interpolation&gt;</span></code>;
<code class="docutils literal notranslate"><span class="pre">reduction</span></code> is the default. The <code class="docutils literal notranslate"><span class="pre">reduction</span></code> method computes the
ratio of the actual reduction in the objective function to the reduction
predicted by the quadratic model for the full step,
<span class="math">\(\kappa_k = \frac{f(x_k) - f(x_k + d_k)}{q(x_k) - q(x_k + d_k)}\)</span>,
where <span class="math">\(q_k\)</span> is the quadratic model. The radius is then updated as</p>
<div class="math">
\[\Delta_{k+1} = \left\{\begin{array}{ll}
\alpha_1 \text{min}(\Delta_k, \|d_k\|) & \text{if } \kappa_k \in (-\infty, \eta_1) \\
\alpha_2 \text{min}(\Delta_k, \|d_k\|) & \text{if } \kappa_k \in [\eta_1, \eta_2) \\
\alpha_3 \Delta_k & \text{if } \kappa_k \in [\eta_2, \eta_3) \\
\text{max}(\Delta_k, \alpha_4 \|d_k\|) & \text{if } \kappa_k \in [\eta_3, \eta_4) \\
\text{max}(\Delta_k, \alpha_5 \|d_k\|) & \text{if } \kappa_k \in [\eta_4, \infty),
\end{array}
\right.\]</div>
<p>where
<span class="math">\(0 &lt; \alpha_1 &lt; \alpha_2 &lt; \alpha_3 = 1 &lt; \alpha_4 &lt; \alpha_5\)</span> and
<span class="math">\(0 &lt; \eta_1 &lt; \eta_2 &lt; \eta_3 &lt; \eta_4\)</span> are constants. The
<code class="docutils literal notranslate"><span class="pre">interpolation</span></code> method uses the same interpolation mechanism as in the
initialization to compute a new value for the trust-region radius.</p>
<p>This algorithm will be deprecated in the next version and replaced by
the Bounded Newton Trust Region (BNTR) algorithm that can solve both
bound constrained and unconstrained problems.</p>
</section>
<section id="newton-trust-region-with-line-search-ntl">
<h5>Newton Trust Region with Line Search (NTL)<a class="headerlink" href="#newton-trust-region-with-line-search-ntl" title="Permalink to this heading">#</a></h5>
<p>NTL safeguards the trust-region globalization such that a line search
is used in the event that the step is initially rejected by the
predicted versus actual decrease comparison. If the line search fails to
find a viable step length for the Newton step, it falls back onto a
scaled gradient or a gradient descent step. The trust radius is then
modified based on the line search step length.</p>
<p>This algorithm will be deprecated in the next version and replaced by
the Bounded Newton Trust Region with Line Search (BNTL) algorithm that
can solve both bound constrained and unconstrained problems.</p>
</section>
</section>
<section id="limited-memory-variable-metric-method-lmvm">
<h4>Limited-Memory Variable-Metric Method (LMVM)<a class="headerlink" href="#limited-memory-variable-metric-method-lmvm" title="Permalink to this heading">#</a></h4>
<p>The limited-memory, variable-metric method (LMVM) computes a positive definite
approximation to the Hessian matrix from a limited number of previous
iterates and gradient evaluations. A direction is then obtained by
solving the system of equations</p>
<div class="math">
\[H_k d_k = -\nabla f(x_k),

\]</div>
<p>where <span class="math">\(H_k\)</span> is the Hessian approximation obtained by using the
BFGS update formula. The inverse of <span class="math">\(H_k\)</span> can readily be applied
to obtain the direction <span class="math">\(d_k\)</span>. Having obtained the direction, a
Moré-Thuente line search is applied to compute a step length,
<span class="math">\(\tau_k\)</span>, that approximately solves the one-dimensional
optimization problem</p>
<div class="math">
\[\min_\tau f(x_k + \tau d_k).

\]</div>
<p>The current iterate and Hessian approximation are updated, and the
process is repeated until the method converges. This algorithm is the
default unconstrained minimization solver and can be selected by using
the TAO solver <code class="docutils literal notranslate"><span class="pre">tao_lmvm</span></code>. For best efficiency, function and gradient
evaluations should be performed simultaneously when using this
algorithm.</p>
<p>The primary factors determining the behavior of this algorithm are the
type of Hessian approximation used, the number of vectors stored for the
approximation and the initialization/scaling of the approximation. These
options can be configured using the <code class="docutils literal notranslate"><span class="pre">-tao_lmvm_mat_lmvm</span></code> prefix. For
further detail, we refer the reader to the <code class="docutils literal notranslate"><span class="pre">MATLMVM</span></code> matrix type
definitions in the PETSc Manual.</p>
<p>The LMVM algorithm also allows the user to define a custom initial
Hessian matrix <span class="math">\(H_{0,k}\)</span> through the interface function
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoLMVMSetH0.html">TaoLMVMSetH0</a>()</span></code>. This user-provided initialization overrides any
other scalar or diagonal initialization inherent to the LMVM
approximation. The provided <span class="math">\(H_{0,k}\)</span> must be a PETSc <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span></code> type
object that represents a positive-definite matrix. The approximation
prefers <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatSolve.html">MatSolve</a>()</span></code> if the provided matrix has <code class="docutils literal notranslate"><span class="pre">MATOP_SOLVE</span></code>
implemented. Otherwise, <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/MatMult.html">MatMult</a>()</span></code> is used in a KSP solve to perform
the inversion of the user-provided initial Hessian.</p>
<p>In applications where <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a>()</span></code> on the LMVM algorithm is repeatedly
called to solve similar or related problems, <code class="docutils literal notranslate"><span class="pre">-tao_lmvm_recycle</span></code> flag
can be used to prevent resetting the LMVM approximation between
subsequent solutions. This recycling also avoids one extra function and
gradient evaluation, instead re-using the values already computed at the
end of the previous solution.</p>
<p>This algorithm will be deprecated in the next version and replaced by
the Bounded Quasi-Newton Line Search (BQNLS) algorithm that can solve
both bound constrained and unconstrained problems.</p>
</section>
<section id="nonlinear-conjugate-gradient-method-cg">
<h4>Nonlinear Conjugate Gradient Method (CG)<a class="headerlink" href="#nonlinear-conjugate-gradient-method-cg" title="Permalink to this heading">#</a></h4>
<p>The nonlinear conjugate gradient method can be viewed as an extension of
the conjugate gradient method for solving symmetric, positive-definite
linear systems of equations. This algorithm requires only function and
gradient evaluations as well as a line search. The TAO implementation
uses a Moré-Thuente line search to obtain the step length. The nonlinear
conjugate gradient method can be selected by using the TAO solver
<code class="docutils literal notranslate"><span class="pre">tao_cg</span></code>. For the best efficiency, function and gradient evaluations
should be performed simultaneously when using this algorithm.</p>
<p>Five variations are currently supported by the TAO implementation: the
Fletcher-Reeves method, the Polak-Ribiére method, the Polak-Ribiére-Plus
method <span id="id4">[<a class="reference internal" href="#id2185" title="Jorge Nocedal and Stephen J. Wright. Numerical Optimization. Springer-Verlag, New York, 1999.">NW99</a>]</span>, the Hestenes-Stiefel method, and the
Dai-Yuan method. These conjugate gradient methods can be specified by
using the command line argument <code class="docutils literal notranslate"><span class="pre">-tao_cg_type</span> <span class="pre">&lt;fr,pr,prp,hs,dy&gt;</span></code>,
respectively. The default value is <code class="docutils literal notranslate"><span class="pre">prp</span></code>.</p>
<p>The conjugate gradient method incorporates automatic restarts when
successive gradients are not sufficiently orthogonal. TAO measures the
orthogonality by dividing the inner product of the gradient at the
current point and the gradient at the previous point by the square of
the Euclidean norm of the gradient at the current point. When the
absolute value of this ratio is greater than <span class="math">\(\eta\)</span>, the algorithm
restarts using the gradient direction. The parameter <span class="math">\(\eta\)</span> can be
set by using the command line argument <code class="docutils literal notranslate"><span class="pre">-tao_cg_eta</span> <span class="pre">&lt;real&gt;</span></code>; 0.1 is
the default value.</p>
<p>This algorithm will be deprecated in the next version and replaced by
the Bounded Nonlinear Conjugate Gradient (BNCG) algorithm that can solve
both bound constrained and unconstrained problems.</p>
</section>
<section id="nelder-mead-simplex-method-nm">
<h4>Nelder-Mead Simplex Method (NM)<a class="headerlink" href="#nelder-mead-simplex-method-nm" title="Permalink to this heading">#</a></h4>
<p>The Nelder-Mead algorithm <span id="id5">[<a class="reference internal" href="#id3307" title="J. A. Nelder and R. Mead. A simplex method for function minimization. Computer Journal, 7:308–313, 1965.">NM65</a>]</span> is a
direct search method for finding a local minimum of a function
<span class="math">\(f(x)\)</span>. This algorithm does not require any gradient or Hessian
information of <span class="math">\(f\)</span> and therefore has some expected advantages and
disadvantages compared to the other TAO solvers. The obvious advantage
is that it is easier to write an application when no derivatives need to
be calculated. The downside is that this algorithm can be slow to
converge or can even stagnate, and it performs poorly for large numbers
of variables.</p>
<p>This solver keeps a set of <span class="math">\(N+1\)</span> sorted vectors
<span class="math">\({x_1,x_2,\ldots,x_{N+1}}\)</span> and their corresponding objective
function values <span class="math">\(f_1 \leq f_2 \leq \ldots \leq f_{N+1}\)</span>. At each
iteration, <span class="math">\(x_{N+1}\)</span> is removed from the set and replaced with</p>
<div class="math">
\[x(\mu) = (1+\mu) \frac{1}{N} \sum_{i=1}^N x_i - \mu x_{N+1},

\]</div>
<p>where <span class="math">\(\mu\)</span> can be one of
<span class="math">\({\mu_0,2\mu_0,\frac{1}{2}\mu_0,-\frac{1}{2}\mu_0}\)</span> depending on
the values of each possible <span class="math">\(f(x(\mu))\)</span>.</p>
<p>The algorithm terminates when the residual <span class="math">\(f_{N+1} - f_1\)</span> becomes
sufficiently small. Because of the way new vectors can be added to the
sorted set, the minimum function value and/or the residual may not be
impacted at each iteration.</p>
<p>Two options can be set specifically for the Nelder-Mead algorithm:</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">-tao_nm_lambda</span> <span class="pre">&lt;value&gt;</span></code></dt><dd><p>sets the initial set of vectors (<span class="math">\(x_0\)</span> plus <code class="docutils literal notranslate"><span class="pre">value</span></code> in each
coordinate direction); the default value is <span class="math">\(1\)</span>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-tao_nm_mu</span> <span class="pre">&lt;value&gt;</span></code></dt><dd><p>sets the value of <span class="math">\(\mu_0\)</span>; the default is <span class="math">\(\mu_0=1\)</span>.</p>
</dd>
</dl>
</section>
</section>
<section id="bound-constrained-optimization">
<span id="sec-tao-bound"></span><h3>Bound-Constrained Optimization<a class="headerlink" href="#bound-constrained-optimization" title="Permalink to this heading">#</a></h3>
<p>Bound-constrained optimization algorithms solve optimization problems of
the form</p>
<div class="math">
\[\begin{array}{ll} \displaystyle
\min_{x} & f(x) \\
\text{subject to} & l \leq x \leq u.
\end{array}\]</div>
<p>These solvers use the bounds on the variables as well as objective
function, gradient, and possibly Hessian information.</p>
<p>For any unbounded variables, the bound value for the associated index
can be set to <code class="docutils literal notranslate"><span class="pre">PETSC_INFINITY</span></code> for the upper bound and
<code class="docutils literal notranslate"><span class="pre">PETSC_NINFINITY</span></code> for the lower bound. If all bounds are set to
infinity, then the bounded algorithms are equivalent to their
unconstrained counterparts.</p>
<p>Before introducing specific methods, we will first define two projection
operations used by all bound constrained algorithms.</p>
<ul>
<li><p>Gradient projection:</p>
<div class="math">
\[\mathfrak{P}(g) = \left\{\begin{array}{ll}
0 & \text{if} \; (x \leq l_i \land g_i > 0) \lor (x \geq u_i \land g_i < 0) \\
g_i & \text{otherwise}
\end{array}
\right.\]</div>
</li>
<li><p>Bound projection:</p>
<div class="math">
\[\mathfrak{B}(x) = \left\{\begin{array}{ll}
l_i & \text{if} \; x_i < l_i \\
u_i & \text{if} \; x_i > u_i \\
x_i & \text{otherwise}
\end{array}
\right.\]</div>
</li>
</ul>
<section id="bounded-newton-krylov-methods">
<span id="sec-bnk"></span><h4>Bounded Newton-Krylov Methods<a class="headerlink" href="#bounded-newton-krylov-methods" title="Permalink to this heading">#</a></h4>
<p>TAO features three bounded Newton-Krylov (BNK) class of algorithms,
separated by their globalization methods: projected line search (BNLS),
trust region (BNTR), and trust region with a projected line search
fall-back (BNTL). They are available via the TAO solvers <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAOBNLS.html">TAOBNLS</a></span></code>,
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAOBNTR.html">TAOBNTR</a></span></code> and <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAOBNTL.html">TAOBNTL</a></span></code>, respectively, or the <code class="docutils literal notranslate"><span class="pre">-tao_type</span></code>
<code class="docutils literal notranslate"><span class="pre">bnls</span></code>/<code class="docutils literal notranslate"><span class="pre">bntr</span></code>/<code class="docutils literal notranslate"><span class="pre">bntl</span></code> flag.</p>
<p>The BNK class of methods use an active-set approach to solve the
symmetric system of equations,</p>
<div class="math">
\[H_k p_k = -g_k,

\]</div>
<p>only for inactive variables in the interior of the bounds. The
active-set estimation is based on Bertsekas
<span id="id6">[<a class="reference internal" href="#id2343" title="Dimitri P. Bertsekas. Projected Newton methods for optimization problems with simple constraints. SIAM Journal on Control and Optimization, 20:221–246, 1982.">Ber82</a>]</span> with the following variable
index categories:</p>
<div class="math">
\[\begin{array}{rlll} \displaystyle
\text{lower bounded}: & \mathcal{L}(x) & = & \{ i \; : \; x_i \leq l_i + \epsilon \; \land \; g(x)_i > 0 \}, \\
\text{upper bounded}: & \mathcal{U}(x) & = & \{ i \; : \; x_i \geq u_i + \epsilon \; \land \; g(x)_i < 0 \}, \\
\text{fixed}: & \mathcal{F}(x) & = & \{ i \; : \; l_i = u_i \}, \\
\text{active-set}: & \mathcal{A}(x) & = & \{ \mathcal{L}(x) \; \bigcup \; \mathcal{U}(x) \; \bigcup \; \mathcal{F}(x) \}, \\
\text{inactive-set}: & \mathcal{I}(x) & = & \{ 1,2,\ldots,n \} \; \backslash \; \mathcal{A}(x).
\end{array}\]</div>
<p>At each iteration, the bound tolerance is estimated as
<span class="math">\(\epsilon_{k+1} = \text{min}(\epsilon_k, ||w_k||_2)\)</span> with
<span class="math">\(w_k = x_k - \mathfrak{B}(x_k - \beta D_k g_k)\)</span>, where the
diagonal matrix <span class="math">\(D_k\)</span> is an approximation of the Hessian inverse
<span class="math">\(H_k^{-1}\)</span>. The initial bound tolerance <span class="math">\(\epsilon_0\)</span> and the
step length <span class="math">\(\beta\)</span> have default values of <span class="math">\(0.001\)</span> and can
be adjusted using <code class="docutils literal notranslate"><span class="pre">-tao_bnk_as_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">-tao_bnk_as_step</span></code> flags,
respectively. The active-set estimation can be disabled using the option
<code class="docutils literal notranslate"><span class="pre">-tao_bnk_as_type</span> <span class="pre">none</span></code>, in which case the algorithm simply uses the
current iterate with no bound tolerances to determine which variables
are actively bounded and which are free.</p>
<p>BNK algorithms invert the reduced Hessian using a Krylov iterative
method. Trust-region conjugate gradient methods (<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/KSP/KSPNASH.html">KSPNASH</a></span></code>,
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/KSP/KSPSTCG.html">KSPSTCG</a></span></code>, and <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/KSP/KSPGLTR.html">KSPGLTR</a></span></code>) are required for the BNTR and BNTL
algorithms, and recommended for the BNLS algorithm. The preconditioner
type can be changed using the <code class="docutils literal notranslate"><span class="pre">-tao_bnk_pc_type</span></code>
<code class="docutils literal notranslate"><span class="pre">none</span></code>/<code class="docutils literal notranslate"><span class="pre">ilu</span></code>/<code class="docutils literal notranslate"><span class="pre">icc</span></code>/<code class="docutils literal notranslate"><span class="pre">jacobi</span></code>/<code class="docutils literal notranslate"><span class="pre">lmvm</span></code>. The <code class="docutils literal notranslate"><span class="pre">lmvm</span></code> option, which
is also the default, preconditions the Krylov solution with a
<code class="docutils literal notranslate"><span class="pre">MATLMVM</span></code> matrix. The remaining supported preconditioner types are
default PETSc types. If Jacobi is selected, the diagonal values are
safeguarded to be positive. <code class="docutils literal notranslate"><span class="pre">icc</span></code> and <code class="docutils literal notranslate"><span class="pre">ilu</span></code> options produce good
results for problems with dense Hessians. The LMVM and Jacobi
preconditioners are also used as the approximate inverse-Hessian in the
active-set estimation. If neither are available, or if the Hessian
matrix does not have <code class="docutils literal notranslate"><span class="pre">MATOP_GET_DIAGONAL</span></code> defined, then the active-set
estimation falls back onto using an identity matrix in place of
<span class="math">\(D_k\)</span> (this is equivalent to estimating the active-set using a
gradient descent step).</p>
<p>A special option is available to <em>accelerate</em> the convergence of the BNK
algorithms by taking a finite number of BNCG iterations at each Newton
iteration. By default, the number of BNCG iterations is set to zero and
the algorithms do not take any BNCG steps. This can be changed using the
option flag <code class="docutils literal notranslate"><span class="pre">-tao_bnk_max_cg_its</span> <span class="pre">&lt;i&gt;</span></code>. While this reduces the number
of Newton iterations, in practice it simply trades off the Hessian
evaluations in the BNK solver for more function and gradient evaluations
in the BNCG solver. However, it may be useful for certain types of
problems where the Hessian evaluation is disproportionately more
expensive than the objective function or its gradient.</p>
<section id="bounded-newton-line-search-bnls">
<span id="sec-bnls"></span><h5>Bounded Newton Line Search (BNLS)<a class="headerlink" href="#bounded-newton-line-search-bnls" title="Permalink to this heading">#</a></h5>
<p>BNLS safeguards the Newton step by falling back onto a BFGS, scaled
gradient, or gradient steps based on descent direction verifications.
For problems with indefinite Hessian matrices, the step direction is
calculated using a perturbed system of equations,</p>
<div class="math">
\[(H_k + \rho_k I)p_k = -g_k,

\]</div>
<p>where <span class="math">\(\rho_k\)</span> is a dynamically adjusted positive constant. The
step is globalized using a projected Moré-Thuente line search. If a
trust-region conjugate gradient method is used for the Hessian
inversion, the trust radius is modified based on the line search step
length.</p>
</section>
<section id="bounded-newton-trust-region-bntr">
<span id="sec-bntr"></span><h5>Bounded Newton Trust Region (BNTR)<a class="headerlink" href="#bounded-newton-trust-region-bntr" title="Permalink to this heading">#</a></h5>
<p>BNTR globalizes the Newton step using a trust region method based on the
predicted versus actual reduction in the cost function. The trust radius
is increased only if the accepted step is at the trust region boundary.
The reduction check features a safeguard for numerical values below
machine epsilon, scaled by the latest function value, where the full
Newton step is accepted without modification.</p>
</section>
<section id="bounded-newton-trust-region-with-line-search-bntl">
<span id="sec-bntl"></span><h5>Bounded Newton Trust Region with Line Search (BNTL)<a class="headerlink" href="#bounded-newton-trust-region-with-line-search-bntl" title="Permalink to this heading">#</a></h5>
<p>BNTL safeguards the trust-region globalization such that a line search
is used in the event that the step is initially rejected by the
predicted versus actual decrease comparison. If the line search fails to
find a viable step length for the Newton step, it falls back onto a
scaled gradient or a gradient descent step. The trust radius is then
modified based on the line search step length.</p>
</section>
</section>
<section id="bounded-quasi-newton-line-search-bqnls">
<span id="sec-bqnls"></span><h4>Bounded Quasi-Newton Line Search (BQNLS)<a class="headerlink" href="#bounded-quasi-newton-line-search-bqnls" title="Permalink to this heading">#</a></h4>
<p>The BQNLS algorithm uses the BNLS infrastructure, but replaces the step
calculation with a direct inverse application of the approximate Hessian
based on quasi-Newton update formulas. No Krylov solver is used in the
solution, and therefore the quasi-Newton method chosen must guarantee a
positive-definite Hessian approximation. This algorithm is available via
<code class="docutils literal notranslate"><span class="pre">tao_type</span> <span class="pre">bqnls</span></code>.</p>
</section>
<section id="bounded-quasi-newton-krylov">
<span id="sec-bqnk"></span><h4>Bounded Quasi-Newton-Krylov<a class="headerlink" href="#bounded-quasi-newton-krylov" title="Permalink to this heading">#</a></h4>
<p>BQNK algorithms use the BNK infrastructure, but replace the exact
Hessian with a quasi-Newton approximation. The matrix-free forward
product operation based on quasi-Newton update formulas are used in
conjunction with Krylov solvers to compute step directions. The
quasi-Newton inverse application is used to precondition the Krylov
solution, and typically helps converge to a step direction in
<span class="math">\(\mathcal{O}(10)\)</span> iterations. This approach is most useful with
quasi-Newton update types such as Symmetric Rank-1 that cannot strictly
guarantee positive-definiteness. The BNLS framework with Hessian
shifting, or the BNTR framework with trust region safeguards, can
successfully compensate for the Hessian approximation becoming
indefinite.</p>
<p>Similar to the full Newton-Krylov counterpart, BQNK algorithms come in
three forms separated by the globalization technique: line search
(BQNKLS), trust region (BQNKTR) and trust region w/ line search
fall-back (BQNKTL). These algorithms are available via
<code class="docutils literal notranslate"><span class="pre">tao_type</span> <span class="pre">&lt;bqnkls,</span> <span class="pre">bqnktr,</span> <span class="pre">bqnktl&gt;</span></code>.</p>
</section>
<section id="bounded-nonlinear-conjugate-gradient-bncg">
<span id="sec-bncg"></span><h4>Bounded Nonlinear Conjugate Gradient (BNCG)<a class="headerlink" href="#bounded-nonlinear-conjugate-gradient-bncg" title="Permalink to this heading">#</a></h4>
<p>BNCG extends the unconstrained nonlinear conjugate gradient algorithm to
bound constraints via gradient projections and a bounded Moré-Thuente
line search.</p>
<p>Like its unconstrained counterpart, BNCG offers gradient descent and a
variety of CG updates: Fletcher-Reeves, Polak-Ribiére,
Polak-Ribiére-Plus, Hestenes-Stiefel, Dai-Yuan, Hager-Zhang, Dai-Kou,
Kou-Dai, and the Self-Scaling Memoryless (SSML) BFGS, DFP, and Broyden
methods. These methods can be specified by using the command line
argument
<code class="docutils literal notranslate"><span class="pre">-tao_bncg_type</span> <span class="pre">&lt;gd,fr,pr,prp,hs,dy,hz,dk,kd,ssml_bfgs,ssml_dfp,ssml_brdn&gt;</span></code>,
respectively. The default value is <code class="docutils literal notranslate"><span class="pre">ssml_bfgs</span></code>. We have scalar
preconditioning for these methods, and it is controlled by the flag
<code class="docutils literal notranslate"><span class="pre">tao_bncg_alpha</span></code>. To disable rescaling, use <span class="math">\(\alpha = -1.0\)</span>,
otherwise <span class="math">\(\alpha \in [0, 1]\)</span>. BNCG is available via the TAO
solver <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAOBNCG.html">TAOBNCG</a></span></code> or the <code class="docutils literal notranslate"><span class="pre">-tao_type</span> <span class="pre">bncg</span></code> flag.</p>
<p>Some individual methods also contain their own parameters. The
Hager-Zhang and Dou-Kai methods have a parameter that determines the
minimum amount of contribution the previous search direction gives to
the next search direction. The flags are <code class="docutils literal notranslate"><span class="pre">-tao_bncg_hz_eta</span></code> and
<code class="docutils literal notranslate"><span class="pre">-tao_bncg_dk_eta</span></code>, and by default are set to <span class="math">\(0.4\)</span> and
<span class="math">\(0.5\)</span> respectively. The Kou-Dai method has multiple parameters.
<code class="docutils literal notranslate"><span class="pre">-tao_bncg_zeta</span></code> serves the same purpose as the previous two; set to
<span class="math">\(0.1\)</span> by default. There is also a parameter to scale the
contribution of <span class="math">\(y_k \equiv \nabla f(x_k) - \nabla f(x_{k-1})\)</span> in
the search direction update. It is controlled by <code class="docutils literal notranslate"><span class="pre">-tao_bncg_xi</span></code>, and
is equal to <span class="math">\(1.0\)</span> by default. There are also times where we want
to maximize the descent as measured by <span class="math">\(\nabla f(x_k)^T d_k\)</span>, and
that may be done by using a negative value of <span class="math">\(\xi\)</span>; this achieves
better performance when not using the diagonal preconditioner described
next. This is enabled by default, and is controlled by
<code class="docutils literal notranslate"><span class="pre">-tao_bncg_neg_xi</span></code>. Finally, the Broyden method has its convex
combination parameter, set with <code class="docutils literal notranslate"><span class="pre">-tao_bncg_theta</span></code>. We have this as 1.0
by default, i.e. it is by default the BFGS method. One can also
individually tweak the BFGS and DFP contributions using the
multiplicative constants <code class="docutils literal notranslate"><span class="pre">-tao_bncg_scale</span></code>; both are set to <span class="math">\(1\)</span>
by default.</p>
<p>All methods can be scaled using the parameter <code class="docutils literal notranslate"><span class="pre">-tao_bncg_alpha</span></code>, which
continuously varies in <span class="math">\([0, 1]\)</span>. The default value is set
depending on the method from initial testing.</p>
<p>BNCG also offers a special type of method scaling. It employs Broyden
diagonal scaling as an option for its CG methods, turned on with the
flag <code class="docutils literal notranslate"><span class="pre">-tao_bncg_diag_scaling</span></code>. Formulations for both the forward
(regular) and inverse Broyden methods are developed, controlled by the
flag <code class="docutils literal notranslate"><span class="pre">-tao_bncg_mat_lmvm_forward</span></code>. It is set to True by default.
Whether one uses the forward or inverse formulations depends on the
method being used. For example, in our preliminary computations, the
forward formulation works better for the SSML_BFGS method, but the
inverse formulation works better for the Hestenes-Stiefel method. The
convex combination parameter for the Broyden scaling is controlled by
<code class="docutils literal notranslate"><span class="pre">-tao_bncg_mat_lmvm_theta</span></code>, and is 0 by default. We also employ
rescaling of the Broyden diagonal, which aids the linesearch immensely.
The rescaling parameter is controlled by <code class="docutils literal notranslate"><span class="pre">-tao_bncg_mat_lmvm_alpha</span></code>,
and should be <span class="math">\(\in [0, 1]\)</span>. One can disable rescaling of the
Broyden diagonal entirely by setting
<code class="docutils literal notranslate"><span class="pre">-tao_bncg_mat_lmvm_sigma_hist</span> <span class="pre">0</span></code>.</p>
<p>One can also supply their own preconditioner, serving as a Hessian
initialization to the above diagonal scaling. The appropriate user
function in the code is <code class="docutils literal notranslate"><span class="pre">TaoBNCGSetH0(tao,</span> <span class="pre">H0)</span></code> where <code class="docutils literal notranslate"><span class="pre">H0</span></code> is the
user-defined <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Mat/Mat.html">Mat</a></span></code> object that serves as a preconditioner. For an
example of similar usage, see <code class="docutils literal notranslate"><span class="pre">tao/tutorials/ex3.c</span></code>.</p>
<p>The active set estimation uses the Bertsekas-based method described in
<a class="reference internal" href="#sec-bnk"><span class="std std-ref">Bounded Newton-Krylov Methods</span></a>, which can be deactivated using
<code class="docutils literal notranslate"><span class="pre">-tao_bncg_as_type</span> <span class="pre">none</span></code>, in which case the algorithm will use the
current iterate to determine the bounded variables with no tolerances
and no look-ahead step. As in the BNK algorithm, the initial bound
tolerance and estimator step length used in the Bertsekas method can be
set via <code class="docutils literal notranslate"><span class="pre">-tao_bncg_as_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">-tao_bncg_as_step</span></code>, respectively.</p>
<p>In addition to automatic scaled gradient descent restarts under certain
local curvature conditions, we also employ restarts based on a check on
descent direction such that
<span class="math">\(\nabla f(x_k)^T d_k \in [-10^{11}, -10^{-9}]\)</span>. Furthermore, we
allow for a variety of alternative restart strategies, all disabled by
default. The <code class="docutils literal notranslate"><span class="pre">-tao_bncg_unscaled_restart</span></code> flag allows one to disable
rescaling of the gradient for gradient descent steps. The
<code class="docutils literal notranslate"><span class="pre">-tao_bncg_spaced_restart</span></code> flag tells the solver to restart every
<span class="math">\(Mn\)</span> iterations, where <span class="math">\(n\)</span> is the problem dimension and
<span class="math">\(M\)</span> is a constant determined by <code class="docutils literal notranslate"><span class="pre">-tao_bncg_min_restart_num</span></code> and
is 6 by default. We also have dynamic restart strategies based on
checking if a function is locally quadratic; if so, go do a gradient
descent step. The flag is <code class="docutils literal notranslate"><span class="pre">-tao_bncg_dynamic_restart</span></code>, disabled by
default since the CG solver usually does better in those cases anyway.
The minimum number of quadratic-like steps before a restart is set using
<code class="docutils literal notranslate"><span class="pre">-tao_bncg_min_quad</span></code> and is 6 by default.</p>
</section>
</section>
<section id="generally-constrained-solvers">
<h3>Generally Constrained Solvers<a class="headerlink" href="#generally-constrained-solvers" title="Permalink to this heading">#</a></h3>
<p>Constrained solvers solve optimization problems that incorporate either or both
equality and inequality constraints, and may optionally include bounds on
solution variables.</p>
<section id="alternating-direction-method-of-multipliers-admm">
<h4>Alternating Direction Method of Multipliers (ADMM)<a class="headerlink" href="#alternating-direction-method-of-multipliers-admm" title="Permalink to this heading">#</a></h4>
<p>The TAOADMM algorithm is intended to blend the decomposability
of dual ascent with the superior convergence properties of the method of
multipliers. <span id="id7">[<a class="reference internal" href="#id2214" title="Stephen Boyd, Neal Parikh, Eric Chu, Borja Peleato, Jonathan Eckstein, and others. Distributed optimization and statistical learning via the alternating direction method of multipliers. Foundations and Trends® in Machine learning, 3(1):1-122, 2011.">BPC+11</a>]</span> The algorithm solves problems in
the form</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{x} & f(x) + g(z) \\
\text{subject to} & Ax + Bz = c
\end{array}\]</div>
<p>where <span class="math">\(x \in \mathbb R^n\)</span>, <span class="math">\(z \in \mathbb R^m\)</span>,
<span class="math">\(A \in \mathbb R^{p \times n}\)</span>,
<span class="math">\(B \in \mathbb R^{p \times m}\)</span>, and <span class="math">\(c \in \mathbb R^p\)</span>.
Essentially, ADMM is a wrapper over two TAO solver, one for
<span class="math">\(f(x)\)</span>, and one for <span class="math">\(g(z)\)</span>. With method of multipliers, one
can form the augmented Lagrangian</p>
<div class="math">
\[L_{\rho}(x,z,y) = f(x) + g(z) + y^T(Ax+Bz-c) + (\rho/2)||Ax+Bz-c||_2^2

\]</div>
<p>Then, ADMM consists of the iterations</p>
<div class="math">
\[x^{k+1} := \text{argmin}L_{\rho}(x,z^k,y^k)

\]</div>
<div class="math">
\[z^{k+1} := \text{argmin}L_{\rho}(x^{k+1},z,y^k)

\]</div>
<div class="math">
\[y^{k+1} := y^k + \rho(Ax^{k+1}+Bz^{k+1}-c)

\]</div>
<p>In certain formulation of ADMM, solution of <span class="math">\(z^{k+1}\)</span> may have
closed-form solution. Currently ADMM provides one default implementation
for <span class="math">\(z^{k+1}\)</span>, which is soft-threshold. It can be used with either
<code class="docutils literal notranslate"><span class="pre">TaoADMMSetRegularizerType_ADMM()</span></code> or
<code class="docutils literal notranslate"><span class="pre">-tao_admm_regularizer_type</span> <span class="pre">&lt;regularizer_soft_thresh&gt;</span></code>. User can also
pass spectral penalty value, <span class="math">\(\rho\)</span>, with either
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoADMMSetSpectralPenalty.html">TaoADMMSetSpectralPenalty</a>()</span></code> or <code class="docutils literal notranslate"><span class="pre">-tao_admm_spectral_penalty</span></code>.
Currently, user can use</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoADMMSetMisfitObjectiveAndGradientRoutine.html">TaoADMMSetMisfitObjectiveAndGradientRoutine</a>()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoADMMSetRegularizerObjectiveAndGradientRoutine.html">TaoADMMSetRegularizerObjectiveAndGradientRoutine</a>()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoADMMSetMisfitHessianRoutine.html">TaoADMMSetMisfitHessianRoutine</a>()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoADMMSetRegularizerHessianRoutine.html">TaoADMMSetRegularizerHessianRoutine</a>()</span></code></p></li>
</ul>
<p>Any other combination of routines is currently not supported. Hessian
matrices can either be constant or non-constant, of which fact can be
set via <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoADMMSetMisfitHessianChangeStatus.html">TaoADMMSetMisfitHessianChangeStatus</a>()</span></code>, and
<code class="docutils literal notranslate"><span class="pre">TaoADMMSetRegularizerHessianChangeStatus()</span></code>. Also, it may appear in
certain cases where augmented Lagrangian’s Hessian may become nearly
singular depending on the <span class="math">\(\rho\)</span>, which may change in the case of
<code class="docutils literal notranslate"><span class="pre">-tao_admm_dual_update</span> <span class="pre">&lt;update_adaptive&gt;,</span> <span class="pre">&lt;update_adaptive_relaxed&gt;</span></code>.
This issue can be prevented by <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoADMMSetMinimumSpectralPenalty.html">TaoADMMSetMinimumSpectralPenalty</a>()</span></code>.</p>
</section>
<section id="augmented-lagrangian-method-of-multipliers-almm">
<h4>Augmented Lagrangian Method of Multipliers (ALMM)<a class="headerlink" href="#augmented-lagrangian-method-of-multipliers-almm" title="Permalink to this heading">#</a></h4>
<p>The TAOALMM method solves generally constrained problems of the form</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{x} & f(x) \\
\text{subject to} & g(x) = 0\\
                  & h(x) \geq 0 \\
                  & l \leq x \leq u
\end{array}\]</div>
<p>where <span class="math">\(g(x)\)</span> are equality constraints, <span class="math">\(h(x)\)</span> are inequality
constraints and <span class="math">\(l\)</span> and <span class="math">\(u\)</span> are lower and upper bounds on
the optimization variables, respectively.</p>
<p>TAOALMM converts the above general constrained problem into a sequence
of bound constrained problems at each outer iteration
<span class="math">\(k = 1,2,\dots\)</span></p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{x} & L(x, \lambda_k) \\
\text{subject to} & l \leq x \leq u
\end{array}\]</div>
<p>where <span class="math">\(L(x, \lambda_k)\)</span> is the augmented Lagrangian merit function
and <span class="math">\(\lambda_k\)</span> is the Lagrange multiplier estimates at outer
iteration <span class="math">\(k\)</span>.</p>
<p>TAOALMM offers two versions of the augmented Lagrangian formulation: the
canonical Hestenes-Powell augmented
Lagrangian <span id="id8">[<a class="reference internal" href="#id3785" title="Magnus R Hestenes. Multiplier and gradient methods. Journal of optimization theory and applications, 4(5):303–320, 1969.">Hes69</a>]</span> <span id="id9">[<a class="reference internal" href="#id3786" title="Michael JD Powell. A method for nonlinear constraints in minimization problems. Optimization, pages 283–298, 1969.">Pow69</a>]</span>
with inequality constrained converted to equality constraints via slack
variables, and the slack-less Powell-Hestenes-Rockafellar
formulation <span id="id10">[<a class="reference internal" href="#id3788" title="R Tyrrell Rockafellar. Augmented lagrange multiplier functions and duality in nonconvex programming. SIAM Journal on Control, 12(2):268–285, 1974.">Roc74</a>]</span> that utilizes a
pointwise <code class="docutils literal notranslate"><span class="pre">max()</span></code> on the inequality constraints. For most
applications, the canonical Hestenes-Powell formulation is likely to
perform better. However, the PHR formulation may be desirable for
problems featuring very large numbers of inequality constraints as it
avoids inflating the dimension of the subproblem with slack variables.</p>
<p>The inner subproblem is solved using a nested bound-constrained
first-order TAO solver. By default, TAOALM uses a quasi-Newton-Krylov
trust-region method (TAOBQNKTR). Other first-order methods such as
TAOBNCG and TAOBQNLS are also appropriate, but a trust-region
globalization is strongly recommended for most applications.</p>
</section>
<section id="primal-dual-interior-point-method-pdipm">
<h4>Primal-Dual Interior-Point Method (PDIPM)<a class="headerlink" href="#primal-dual-interior-point-method-pdipm" title="Permalink to this heading">#</a></h4>
<p>The TAOPDIPM method (<code class="docutils literal notranslate"><span class="pre">-tao_type</span> <span class="pre">pdipm</span></code>) implements a primal-dual interior
point method for solving general nonlinear programming problems of the form</p>
<div class="math" id="equation-eq-nlp-gen1">
<span class="eqno">(6)<a class="headerlink" href="#equation-eq-nlp-gen1" title="Permalink to this equation">#</a></span>\[\begin{array}{ll}
\displaystyle \min_{x} & f(x) \\
\text{subject to} & g(x) = 0 \\
                  & h(x) \geq 0 \\
                  & x^- \leq x \leq x^+
\end{array}\]</div>
<p>Here, <span class="math">\(f(x)\)</span> is the nonlinear objective function, <span class="math">\(g(x)\)</span>,
<span class="math">\(h(x)\)</span> are the equality and inequality constraints, and
<span class="math">\(x^-\)</span> and <span class="math">\(x^+\)</span> are the lower and upper bounds on decision
variables <span class="math">\(x\)</span>.</p>
<p>PDIPM converts the inequality constraints to equalities using slack variables
<span class="math">\(z\)</span> and a log-barrier term, which transforms <a class="reference internal" href="#equation-eq-nlp-gen1">(6)</a> to</p>
<div class="math" id="equation-eq-nlp-gen2">
<span class="eqno">(7)<a class="headerlink" href="#equation-eq-nlp-gen2" title="Permalink to this equation">#</a></span>\[\begin{aligned}
    \text{min}~&f(x) - \mu\sum_{i=1}^{nci}\ln z_i\\
    \text{s.t.}& \\
        &ce(x) = 0 \\
        &ci(x) - z = 0 \\
    \end{aligned}\]</div>
<p>Here, <span class="math">\(ce(x)\)</span> is set of equality constraints that include
<span class="math">\(g(x)\)</span> and fixed decision variables, i.e., <span class="math">\(x^- = x = x^+\)</span>.
Similarly, <span class="math">\(ci(x)\)</span> are inequality constraints including
<span class="math">\(h(x)\)</span> and lower/upper/box-constraints on <span class="math">\(x\)</span>. <span class="math">\(\mu\)</span>
is a parameter that is driven to zero as the optimization progresses.</p>
<p>The Lagrangian for <a class="reference internal" href="#equation-eq-nlp-gen2">(7)</a>) is</p>
<div class="math" id="equation-eq-lagrangian">
<span class="eqno">(8)<a class="headerlink" href="#equation-eq-lagrangian" title="Permalink to this equation">#</a></span>\[L_{\mu}(x,\lambda_{ce},\lambda_{ci},z) = f(x) + \lambda_{ce}^Tce(x) - \lambda_{ci}^T(ci(x) - z) - \mu\sum_{i=1}^{nci}\ln z_i\]</div>
<p>where, <span class="math">\(\lambda_{ce}\)</span> and <span class="math">\(\lambda_{ci}\)</span> are the Lagrangian
multipliers for the equality and inequality constraints, respectively.</p>
<p>The first order KKT conditions for optimality are as follows</p>
<div class="math" id="equation-eq-nlp-kkt">
<span class="eqno">(9)<a class="headerlink" href="#equation-eq-nlp-kkt" title="Permalink to this equation">#</a></span>\[\nabla L_{\mu}(x,\lambda_{ce},\lambda_{ci},z)    =
    \begin{bmatrix}
        \nabla f(x) + \nabla ce(x)^T\lambda_{ce} -  \nabla ci(x)^T \lambda_{ci} \\
        ce(x) \\
        ci(x) - z \\
        Z\Lambda_{ci}e - \mu e
    \end{bmatrix}
= 0\]</div>
<p><a class="reference internal" href="#equation-eq-nlp-kkt">(9)</a> is solved iteratively using Newton’s
method using PETSc’s SNES object. After each Newton iteration, a
line-search is performed to update <span class="math">\(x\)</span> and enforce
<span class="math">\(z,\lambda_{ci} \geq 0\)</span>. The barrier parameter <span class="math">\(\mu\)</span> is also
updated after each Newton iteration. The Newton update is obtained by
solving the second-order KKT system <span class="math">\(Hd = -\nabla L_{\mu}\)</span>.
Here,<span class="math">\(H\)</span> is the Hessian matrix of the KKT system. For
interior-point methods such as PDIPM, the Hessian matrix tends to be
ill-conditioned, thus necessitating the use of a direct solver. We
recommend using LU preconditioner <code class="docutils literal notranslate"><span class="pre">-pc_type</span> <span class="pre">lu</span></code> and using direct
linear solver packages such <code class="docutils literal notranslate"><span class="pre">SuperLU_Dist</span></code> or <code class="docutils literal notranslate"><span class="pre">MUMPS</span></code>.</p>
</section>
</section>
<section id="id11">
<h3>PDE-Constrained Optimization<a class="headerlink" href="#id11" title="Permalink to this heading">#</a></h3>
<p>TAO solves PDE-constrained optimization problems of the form</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{u,v} & f(u,v) \\
\text{subject to} & g(u,v) = 0,
\end{array}\]</div>
<p>where the state variable <span class="math">\(u\)</span> is the solution to the discretized
partial differential equation defined by <span class="math">\(g\)</span> and parametrized by
the design variable <span class="math">\(v\)</span>, and <span class="math">\(f\)</span> is an objective function.
The Lagrange multipliers on the constraint are denoted by <span class="math">\(y\)</span>.
This method is set by using the linearly constrained augmented
Lagrangian TAO solver <code class="docutils literal notranslate"><span class="pre">tao_lcl</span></code>.</p>
<p>We make two main assumptions when solving these problems: the objective
function and PDE constraints have been discretized so that we can treat
the optimization problem as finite dimensional and
<span class="math">\(\nabla_u g(u,v)\)</span> is invertible for all <span class="math">\(u\)</span> and <span class="math">\(v\)</span>.</p>
<section id="linearly-constrained-augmented-lagrangian-method-lcl">
<span id="sec-lcl"></span><h4>Linearly-Constrained Augmented Lagrangian Method (LCL)<a class="headerlink" href="#linearly-constrained-augmented-lagrangian-method-lcl" title="Permalink to this heading">#</a></h4>
<p>Given the current iterate <span class="math">\((u_k, v_k, y_k)\)</span>, the linearly
constrained augmented Lagrangian method approximately solves the
optimization problem</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{u,v} & \tilde{f}_k(u, v) \\
\text{subject to} & A_k (u-u_k) + B_k (v-v_k) + g_k = 0,
\end{array}\]</div>
<p>where <span class="math">\(A_k = \nabla_u g(u_k,v_k)\)</span>,
<span class="math">\(B_k = \nabla_v g(u_k,v_k)\)</span>, and <span class="math">\(g_k = g(u_k, v_k)\)</span> and</p>
<div class="math">
\[\tilde{f}_k(u,v) = f(u,v) - g(u,v)^T y^k + \frac{\rho_k}{2} \| g(u,v) \|^2

\]</div>
<p>is the augmented Lagrangian function. This optimization problem is
solved in two stages. The first computes the Newton direction and finds
a feasible point for the linear constraints. The second computes a
reduced-space direction that maintains feasibility with respect to the
linearized constraints and improves the augmented Lagrangian merit
function.</p>
<section id="newton-step">
<h5>Newton Step<a class="headerlink" href="#newton-step" title="Permalink to this heading">#</a></h5>
<p>The Newton direction is obtained by fixing the design variables at their
current value and solving the linearized constraint for the state
variables. In particular, we solve the system of equations</p>
<div class="math">
\[A_k du = -g_k

\]</div>
<p>to obtain a direction <span class="math">\(du\)</span>. We need a direction that provides
sufficient descent for the merit function</p>
<div class="math">
\[\frac{1}{2} \|g(u,v)\|^2.

\]</div>
<p>That is, we require <span class="math">\(g_k^T A_k du &lt; 0\)</span>.</p>
<p>If the Newton direction is a descent direction, then we choose a penalty
parameter <span class="math">\(\rho_k\)</span> so that <span class="math">\(du\)</span> is also a sufficient descent
direction for the augmented Lagrangian merit function. We then find
<span class="math">\(\alpha\)</span> to approximately minimize the augmented Lagrangian merit
function along the Newton direction.</p>
<div class="math">
\[\displaystyle \min_{\alpha \geq 0} \; \tilde{f}_k(u_k + \alpha du, v_k).

\]</div>
<p>We can enforce either the sufficient decrease condition or the Wolfe
conditions during the search procedure. The new point,</p>
<div class="math">
\[\begin{array}{lcl}
u_{k+\frac{1}{2}} & = & u_k + \alpha_k du \\
v_{k+\frac{1}{2}} & = & v_k,
\end{array}\]</div>
<p>satisfies the linear constraint</p>
<div class="math">
\[A_k (u_{k+\frac{1}{2}} - u_k) + B_k (v_{k+\frac{1}{2}} - v_k) + \alpha_k g_k = 0.

\]</div>
<p>If the Newton direction computed does not provide descent for the merit
function, then we can use the steepest descent direction
<span class="math">\(du = -A_k^T g_k\)</span> during the search procedure. However, the
implication that the intermediate point approximately satisfies the
linear constraint is no longer true.</p>
</section>
<section id="modified-reduced-space-step">
<h5>Modified Reduced-Space Step<a class="headerlink" href="#modified-reduced-space-step" title="Permalink to this heading">#</a></h5>
<p>We are now ready to compute a reduced-space step for the modified
optimization problem:</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{u,v} & \tilde{f}_k(u, v) \\
\text{subject to} & A_k (u-u_k) + B_k (v-v_k) + \alpha_k g_k = 0.
\end{array}\]</div>
<p>We begin with the change of variables</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{du,dv} & \tilde{f}_k(u_k+du, v_k+dv) \\
\text{subject to} & A_k du + B_k dv + \alpha_k g_k = 0
\end{array}\]</div>
<p>and make the substitution</p>
<div class="math">
\[du = -A_k^{-1}(B_k dv + \alpha_k g_k).

\]</div>
<p>Hence, the unconstrained optimization problem we need to solve is</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{dv} & \tilde{f}_k(u_k-A_k^{-1}(B_k dv + \alpha_k g_k), v_k+dv), \\
\end{array}\]</div>
<p>which is equivalent to</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{dv} & \tilde{f}_k(u_{k+\frac{1}{2}} - A_k^{-1} B_k dv, v_{k+\frac{1}{2}}+dv). \\
\end{array}\]</div>
<p>We apply one step of a limited-memory quasi-Newton method to this
problem. The direction is obtain by solving the quadratic problem</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{dv} & \frac{1}{2} dv^T \tilde{H}_k dv + \tilde{g}_{k+\frac{1}{2}}^T dv,
\end{array}\]</div>
<p>where <span class="math">\(\tilde{H}_k\)</span> is the limited-memory quasi-Newton
approximation to the reduced Hessian matrix, a positive-definite matrix,
and <span class="math">\(\tilde{g}_{k+\frac{1}{2}}\)</span> is the reduced gradient.</p>
<div class="math">
\[\begin{array}{lcl}
\tilde{g}_{k+\frac{1}{2}} & = & \nabla_v \tilde{f}_k(u_{k+\frac{1}{2}}, v_{k+\frac{1}{2}}) -
          \nabla_u \tilde{f}_k(u_{k+\frac{1}{2}}, v_{k+\frac{1}{2}}) A_k^{-1} B_k \\
       & = & d_{k+\frac{1}{2}} + c_{k+\frac{1}{2}} A_k^{-1} B_k
\end{array}\]</div>
<p>The reduced gradient is obtained from one linearized adjoint solve</p>
<div class="math">
\[y_{k+\frac{1}{2}} = A_k^{-T}c_{k+\frac{1}{2}}

\]</div>
<p>and some linear algebra</p>
<div class="math">
\[\tilde{g}_{k+\frac{1}{2}} = d_{k+\frac{1}{2}} + y_{k+\frac{1}{2}}^T B_k.

\]</div>
<p>Because the Hessian approximation is positive definite and we know its
inverse, we obtain the direction</p>
<div class="math">
\[dv = -H_k^{-1} \tilde{g}_{k+\frac{1}{2}}

\]</div>
<p>and recover the full-space direction from one linearized forward solve,</p>
<div class="math">
\[du = -A_k^{-1} B_k dv.

\]</div>
<p>Having the full-space direction, which satisfies the linear constraint,
we now approximately minimize the augmented Lagrangian merit function
along the direction.</p>
<div class="math">
\[\begin{array}{lcl}
\displaystyle \min_{\beta \geq 0} & \tilde{f_k}(u_{k+\frac{1}{2}} + \beta du, v_{k+\frac{1}{2}} + \beta dv)
\end{array}\]</div>
<p>We enforce the Wolfe conditions during the search procedure. The new
point is</p>
<div class="math">
\[\begin{array}{lcl}
u_{k+1} & = & u_{k+\frac{1}{2}} + \beta_k du \\
v_{k+1} & = & v_{k+\frac{1}{2}} + \beta_k dv.
\end{array}\]</div>
<p>The reduced gradient at the new point is computed from</p>
<div class="math">
\[\begin{array}{lcl}
y_{k+1} & = & A_k^{-T}c_{k+1} \\
\tilde{g}_{k+1} & = & d_{k+1} - y_{k+1}^T B_k,
\end{array}\]</div>
<p>where <span class="math">\(c_{k+1} = \nabla_u \tilde{f}_k (u_{k+1},v_{k+1})\)</span> and
<span class="math">\(d_{k+1} = \nabla_v \tilde{f}_k (u_{k+1},v_{k+1})\)</span>. The
multipliers <span class="math">\(y_{k+1}\)</span> become the multipliers used in the next
iteration of the code. The quantities <span class="math">\(v_{k+\frac{1}{2}}\)</span>,
<span class="math">\(v_{k+1}\)</span>, <span class="math">\(\tilde{g}_{k+\frac{1}{2}}\)</span>, and
<span class="math">\(\tilde{g}_{k+1}\)</span> are used to update <span class="math">\(H_k\)</span> to obtain the
limited-memory quasi-Newton approximation to the reduced Hessian matrix
used in the next iteration of the code. The update is skipped if it
cannot be performed.</p>
</section>
</section>
</section>
<section id="sec-leastsquares">
<span id="id12"></span><h3>Nonlinear Least-Squares<a class="headerlink" href="#sec-leastsquares" title="Permalink to this heading">#</a></h3>
<p>Given a function <span class="math">\(F: \mathbb R^n \to \mathbb R^m\)</span>, the nonlinear
least-squares problem minimizes</p>
<div class="math" id="equation-eq-nlsf">
<span class="eqno">(10)<a class="headerlink" href="#equation-eq-nlsf" title="Permalink to this equation">#</a></span>\[f(x)= \| F(x) \|_2^2 = \sum_{i=1}^m F_i(x)^2.\]</div>
<p>The nonlinear equations <span class="math">\(F\)</span> should be specified with the function
<code class="docutils literal notranslate"><span class="pre">TaoSetResidual()</span></code>.</p>
<section id="bound-constrained-regularized-gauss-newton-brgn">
<span id="sec-pounders"></span><h4>Bound-constrained Regularized Gauss-Newton (BRGN)<a class="headerlink" href="#bound-constrained-regularized-gauss-newton-brgn" title="Permalink to this heading">#</a></h4>
<p>The TAOBRGN algorithms is a Gauss-Newton method is used to iteratively solve nonlinear least
squares problem with the iterations</p>
<div class="math">
\[x_{k+1} = x_k - \alpha_k(J_k^T J_k)^{-1} J_k^T r(x_k)

\]</div>
<p>where <span class="math">\(r(x)\)</span> is the least-squares residual vector,
<span class="math">\(J_k = \partial r(x_k)/\partial x\)</span> is the Jacobian of the
residual, and <span class="math">\(\alpha_k\)</span> is the step length parameter. In other
words, the Gauss-Newton method approximates the Hessian of the objective
as <span class="math">\(H_k \approx (J_k^T J_k)\)</span> and the gradient of the objective as
<span class="math">\(g_k \approx -J_k r(x_k)\)</span>. The least-squares Jacobian, <span class="math">\(J\)</span>,
should be provided to Tao using <code class="docutils literal notranslate"><span class="pre">TaoSetJacobianResidual()</span></code> routine.</p>
<p>The BRGN (<code class="docutils literal notranslate"><span class="pre">-tao_type</span> <span class="pre">brgn</span></code>) implementation adds a regularization term <span class="math">\(\beta(x)\)</span> such
that</p>
<div class="math">
\[\min_{x} \; \frac{1}{2}||R(x)||_2^2 + \lambda\beta(x),

\]</div>
<p>where <span class="math">\(\lambda\)</span> is the scalar weight of the regularizer. BRGN
provides two default implementations for <span class="math">\(\beta(x)\)</span>:</p>
<ul class="simple">
<li><p><strong>L2-norm</strong> - <span class="math">\(\beta(x) = \frac{1}{2}||x_k||_2^2\)</span></p></li>
<li><p><strong>L2-norm Proximal Point</strong> -
<span class="math">\(\beta(x) = \frac{1}{2}||x_k - x_{k-1}||_2^2\)</span></p></li>
<li><p><strong>L1-norm with Dictionary</strong> -
<span class="math">\(\beta(x) = ||Dx||_1 \approx \sum_{i} \sqrt{y_i^2 + \epsilon^2}-\epsilon\)</span>
where <span class="math">\(y = Dx\)</span> and <span class="math">\(\epsilon\)</span> is the smooth approximation
parameter.</p></li>
</ul>
<p>The regularizer weight can be controlled with either
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoBRGNSetRegularizerWeight.html">TaoBRGNSetRegularizerWeight</a>()</span></code> or <code class="docutils literal notranslate"><span class="pre">-tao_brgn_regularizer_weight</span></code>
command line option, while the smooth approximation parameter can be set
with either <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoBRGNSetL1SmoothEpsilon.html">TaoBRGNSetL1SmoothEpsilon</a>()</span></code> or
<code class="docutils literal notranslate"><span class="pre">-tao_brgn_l1_smooth_epsilon</span></code>. For the L1-norm term, the user can
supply a dictionary matrix with <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoBRGNSetDictionaryMatrix.html">TaoBRGNSetDictionaryMatrix</a>()</span></code>. If no
dictionary is provided, the dictionary is assumed to be an identity
matrix and the regularizer reduces to a sparse solution term.</p>
<p>The regularization selection can be made using the command line option
<code class="docutils literal notranslate"><span class="pre">-tao_brgn_regularization_type</span> <span class="pre">&lt;l2pure,</span> <span class="pre">l2prox,</span> <span class="pre">l1dict,</span> <span class="pre">user&gt;</span></code> where the <code class="docutils literal notranslate"><span class="pre">user</span></code> option allows
the user to define a custom <span class="math">\(\mathcal{C}2\)</span>-continuous
regularization term. This custom term can be defined by using the
interface functions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoBRGNSetRegularizerObjectiveAndGradientRoutine.html">TaoBRGNSetRegularizerObjectiveAndGradientRoutine</a>()</span></code> - Provide
user-call back for evaluating the function value and gradient
evaluation for the regularization term.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoBRGNSetRegularizerHessianRoutine.html">TaoBRGNSetRegularizerHessianRoutine</a>()</span></code> - Provide user call-back
for evaluating the Hessian of the regularization term.</p></li>
</ul>
</section>
<section id="pounders">
<h4>POUNDERS<a class="headerlink" href="#pounders" title="Permalink to this heading">#</a></h4>
<p>One algorithm for solving the least squares problem
(<a class="reference internal" href="#equation-eq-nlsf">(10)</a>) when the Jacobian of the residual vector
<span class="math">\(F\)</span> is unavailable is the model-based POUNDERS (Practical
Optimization Using No Derivatives for sums of Squares) algorithm
(<code class="docutils literal notranslate"><span class="pre">tao_pounders</span></code>). POUNDERS employs a derivative-free trust-region
framework as described in <span id="id13">[<a class="reference internal" href="#id3783" title="Andrew R. Conn, Katya Scheinberg, and Luís N. Vicente. Introduction to Derivative-Free Optimization. MPS/SIAM Series on Optimization. Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 2009. ISBN 0-89871-460-5.">CSV09</a>]</span> in order to
converge to local minimizers. An example of this version of POUNDERS
applied to a practical least-squares problem can be found in
<span id="id14">[<a class="reference internal" href="#id3784" title="M. Kortelainen, T. Lesinski, J. Moré, W. Nazarewicz, J. Sarich, N. Schunck, M. V. Stoitsov, and S. M. Wild. Nuclear energy density optimization. Physical Review C, 82(2):024313, 2010. doi:10.1103/PhysRevC.82.024313.">KortelainenLesinskiMore+10</a>]</span>.</p>
<section id="derivative-free-trust-region-algorithm">
<h5>Derivative-Free Trust-Region Algorithm<a class="headerlink" href="#derivative-free-trust-region-algorithm" title="Permalink to this heading">#</a></h5>
<p>In each iteration <span class="math">\(k\)</span>, the algorithm maintains a model
<span class="math">\(m_k(x)\)</span>, described below, of the nonlinear least squares function
<span class="math">\(f\)</span> centered about the current iterate <span class="math">\(x_k\)</span>.</p>
<p>If one assumes that the maximum number of function evaluations has not
been reached and that <span class="math">\(\|\nabla m_k(x_k)\|_2&gt;\)</span><code class="docutils literal notranslate"><span class="pre">gtol</span></code>, the next
point <span class="math">\(x_+\)</span> to be evaluated is obtained by solving the
trust-region subproblem</p>
<div class="math" id="equation-eq-poundersp">
<span class="eqno">(11)<a class="headerlink" href="#equation-eq-poundersp" title="Permalink to this equation">#</a></span>\[\min\left\{
 m_k(x) :
 \|x-x_k\|_{p} \leq \Delta_k,
 \right \},\]</div>
<p>where <span class="math">\(\Delta_k\)</span> is the current trust-region radius. By default we
use a trust-region norm with <span class="math">\(p=\infty\)</span> and solve
(<a class="reference internal" href="#equation-eq-poundersp">(11)</a>) with the BLMVM method described in
<a class="reference internal" href="#sec-blmvm"><span class="std std-ref">Bound-constrained Limited-Memory Variable-Metric Method (BLMVM)</span></a>. While the subproblem is a
bound-constrained quadratic program, it may not be convex and the BQPIP
and GPCG methods may not solve the subproblem. Therefore, a bounded
Newton-Krylov Method should be used; the default is the BNTR
algorithm.  Note: BNTR uses its own internal
trust region that may interfere with the infinity-norm trust region used
in the model problem (<a class="reference internal" href="#equation-eq-poundersp">(11)</a>).</p>
<p>The residual vector is then evaluated to obtain <span class="math">\(F(x_+)\)</span> and hence
<span class="math">\(f(x_+)\)</span>. The ratio of actual decrease to predicted decrease,</p>
<div class="math">
\[\rho_k = \frac{f(x_k)-f(x_+)}{m_k(x_k)-m_k(x_+)},

\]</div>
<p>as well as an indicator, <code class="docutils literal notranslate"><span class="pre">valid</span></code>, on the model’s quality of
approximation on the trust region is then used to update the iterate,</p>
<div class="math">
\[x_{k+1} = \left\{\begin{array}{ll}
x_+ & \text{if } \rho_k \geq \eta_1 \\
x_+ & \text{if } 0<\rho_k <\eta_1  \text{ and \texttt{valid}=\texttt{true}}
\\
x_k & \text{else},
\end{array}
\right.\]</div>
<p>and trust-region radius,</p>
<div class="math">
\[\Delta_{k+1} = \left\{\begin{array}{ll}
 \text{min}(\gamma_1\Delta_k, \Delta_{\max}) & \text{if } \rho_k \geq
\eta_1 \text{ and } \|x_+-x_k\|_p\geq \omega_1\Delta_k \\
\gamma_0\Delta_k & \text{if } \rho_k < \eta_1 \text{ and
\texttt{valid}=\texttt{true}} \\
\Delta_k &  \text{else,}
\end{array}
\right.\]</div>
<p>where <span class="math">\(0 &lt; \eta_1 &lt; 1\)</span>, <span class="math">\(0 &lt; \gamma_0 &lt; 1 &lt; \gamma_1\)</span>,
<span class="math">\(0&lt;\omega_1&lt;1\)</span>, and <span class="math">\(\Delta_{\max}\)</span> are constants.</p>
<p>If <span class="math">\(\rho_k\leq 0\)</span> and <code class="docutils literal notranslate"><span class="pre">valid</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, the iterate and
trust-region radius remain unchanged after the above updates, and the
algorithm tests whether the direction <span class="math">\(x_+-x_k\)</span> improves the
model. If not, the algorithm performs an additional evaluation to obtain
<span class="math">\(F(x_k+d_k)\)</span>, where <span class="math">\(d_k\)</span> is a model-improving direction.</p>
<p>The iteration counter is then updated, and the next model <span class="math">\(m_{k}\)</span>
is obtained as described next.</p>
</section>
<section id="forming-the-trust-region-model">
<h5>Forming the Trust-Region Model<a class="headerlink" href="#forming-the-trust-region-model" title="Permalink to this heading">#</a></h5>
<p>In each iteration, POUNDERS uses a subset of the available evaluated
residual vectors <span class="math">\(\{ F(y_1), F(y_2), \cdots \}\)</span> to form an
interpolatory quadratic model of each residual component. The <span class="math">\(m\)</span>
quadratic models</p>
<div class="math" id="equation-eq-models">
<span class="eqno">(12)<a class="headerlink" href="#equation-eq-models" title="Permalink to this equation">#</a></span>\[q_k^{(i)}(x) =
 F_i(x_k) + (x-x_k)^T g_k^{(i)} + \frac{1}{2} (x-x_k)^T H_k^{(i)} (x-x_k),
 \qquad i = 1, \ldots, m\]</div>
<p>thus satisfy the interpolation conditions</p>
<div class="math">
\[q_k^{(i)}(y_j) = F_i(y_j), \qquad i=1, \ldots, m; \, j=1,\ldots , l_k

\]</div>
<p>on a common interpolation set <span class="math">\(\{y_1, \cdots , y_{l_k}\}\)</span> of size
<span class="math">\(l_k\in[n+1,\)</span><code class="docutils literal notranslate"><span class="pre">npmax</span></code><span class="math">\(]\)</span>.</p>
<p>The gradients and Hessians of the models in
(<cite>:eq:eq_models</cite>) are then used to construct the main
model,</p>
<div class="math" id="equation-eq-newton2">
<span class="eqno">(13)<a class="headerlink" href="#equation-eq-newton2" title="Permalink to this equation">#</a></span>\[ m_k(x) = f(x_k) +
 2(x-x_k)^T \sum_{i=1}^{m} F_i(x_k) g_k^{(i)} +
 (x-x_k)^T \sum_{i=1}^{m}
 \left( g_k^{(i)} \left(g_k^{(i)}\right)^T +  F_i(x_k)
 H_k^{(i)}\right) (x-x_k).\]</div>
<p>The process of forming these models also computes the indicator
<code class="docutils literal notranslate"><span class="pre">valid</span></code> of the model’s local quality.</p>
</section>
<section id="parameters">
<h5>Parameters<a class="headerlink" href="#parameters" title="Permalink to this heading">#</a></h5>
<p>POUNDERS supports the following parameters that can be set from the
command line or PETSc options file:</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">-tao_pounders_delta</span> <span class="pre">&lt;delta&gt;</span></code></dt><dd><p>The initial trust-region radius (<span class="math">\(&gt;0\)</span>, real). This is used to
determine the size of the initial neighborhood within which the
algorithm should look.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-tao_pounders_npmax</span> <span class="pre">&lt;npmax&gt;</span></code></dt><dd><p>The maximum number of interpolation points used (<span class="math">\(n+2\leq\)</span>
<code class="docutils literal notranslate"><span class="pre">npmax</span></code> <span class="math">\(\leq 0.5(n+1)(n+2)\)</span>). This input is made available
to advanced users. We recommend the default value
(<code class="docutils literal notranslate"><span class="pre">npmax</span></code><span class="math">\(=2n+1\)</span>) be used by others.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-tao_pounders_gqt</span></code></dt><dd><p>Use the gqt algorithm to solve the
subproblem (<a class="reference internal" href="#equation-eq-poundersp">(11)</a>) (uses <span class="math">\(p=2\)</span>)
instead of BQPIP.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-pounders_subsolver</span></code></dt><dd><p>If the default BQPIP algorithm is used to solve the
subproblem (<a class="reference internal" href="#equation-eq-poundersp">(11)</a>), the parameters of
the subproblem solver can be accessed using the command line options
prefix <code class="docutils literal notranslate"><span class="pre">-pounders_subsolver_</span></code>. For example,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">-</span><span class="n">pounders_subsolver_tao_gatol</span><span class="w"> </span><span class="mf">1.0e-5</span>
</pre></div>
</div>
<p>sets the gradient tolerance of the subproblem solver to
<span class="math">\(10^{-5}\)</span>.</p>
</dd>
</dl>
<p>Additionally, the user provides an initial solution vector, a vector for
storing the separable objective function, and a routine for evaluating
the residual vector <span class="math">\(F\)</span>. These are described in detail in
<a class="reference internal" href="#sec-fghj"><span class="std std-ref">Objective Function and Gradient Routines</span></a> and
<a class="reference internal" href="#sec-evalsof"><span class="std std-ref">Nonlinear Least Squares</span></a>. Here we remark that because gradient
information is not available for scaling purposes, it can be useful to
ensure that the problem is reasonably well scaled. A simple way to do so
is to rescale the decision variables <span class="math">\(x\)</span> so that their typical
values are expected to lie within the unit hypercube <span class="math">\([0,1]^n\)</span>.</p>
</section>
<section id="convergence-notes">
<h5>Convergence Notes<a class="headerlink" href="#convergence-notes" title="Permalink to this heading">#</a></h5>
<p>Because the gradient function is not provided to POUNDERS, the norm of
the gradient of the objective function is not available. Therefore, for
convergence criteria, this norm is approximated by the norm of the model
gradient and used only when the model gradient is deemed to be a
reasonable approximation of the gradient of the objective. In practice,
the typical grounds for termination for expensive derivative-free
problems is the maximum number of function evaluations allowed.</p>
</section>
</section>
</section>
<section id="sec-complementarity">
<span id="id15"></span><h3>Complementarity<a class="headerlink" href="#sec-complementarity" title="Permalink to this heading">#</a></h3>
<p>Mixed complementarity problems, or box-constrained variational
inequalities, are related to nonlinear systems of equations. They are
defined by a continuously differentiable function,
<span class="math">\(F:\mathbb R^n \to \mathbb R^n\)</span>, and bounds,
<span class="math">\(\ell \in \{\mathbb R\cup \{-\infty\}\}^n\)</span> and
<span class="math">\(u \in \{\mathbb R\cup \{\infty\}\}^n\)</span>, on the variables such that
<span class="math">\(\ell \leq u\)</span>. Given this information,
<span class="math">\(\mathbf{x}^* \in [\ell,u]\)</span> is a solution to
MCP(<span class="math">\(F\)</span>, <span class="math">\(\ell\)</span>, <span class="math">\(u\)</span>) if for each
<span class="math">\(i \in \{1, \ldots, n\}\)</span> we have at least one of the following:</p>
<div class="math">
\[\begin{aligned}
\begin{array}{ll}
F_i(x^*) \geq 0 & \text{if } x^*_i = \ell_i \\
F_i(x^*) = 0 & \text{if } \ell_i < x^*_i < u_i \\
F_i(x^*) \leq 0 & \text{if } x^*_i = u_i.
\end{array}\end{aligned}\]</div>
<p>Note that when <span class="math">\(\ell = \{-\infty\}^n\)</span> and
<span class="math">\(u = \{\infty\}^n\)</span>, we have a nonlinear system of equations, and
<span class="math">\(\ell = \{0\}^n\)</span> and <span class="math">\(u = \{\infty\}^n\)</span> correspond to the
nonlinear complementarity problem <span id="id16">[<a class="reference internal" href="#id2514" title="R. W. Cottle. Nonlinear programs with positively bounded Jacobians. PhD thesis, Department of Mathematics, University of California, Berkeley, California, 1964.">Cot64</a>]</span>.</p>
<p>Simple complementarity conditions arise from the first-order optimality
conditions from optimization
<span id="id17">[<a class="reference internal" href="#id3000" title="W. Karush. Minima of functions of several variables with inequalities as side conditions. Master's thesis, Department of Mathematics, University of Chicago, 1939.">Kar39</a>]</span> <span id="id18">[<a class="reference internal" href="#id3056" title="H. W. Kuhn and A. W. Tucker. Nonlinear programming. In J. Neyman, editor, Proceedings of the Second Berkeley Symposium on Mathematical Statistics and Probability, pages 481–492. University of California Press, Berkeley and Los Angeles, 1951.">KT51</a>]</span>. In the simple
bound-constrained optimization case, these conditions correspond to
MCP(<span class="math">\(\nabla f\)</span>, <span class="math">\(\ell\)</span>, <span class="math">\(u\)</span>), where
<span class="math">\(f: \mathbb R^n \to \mathbb R\)</span> is the objective function. In a
one-dimensional setting these conditions are intuitive. If the solution
is at the lower bound, then the function must be increasing and
<span class="math">\(\nabla f \geq 0\)</span>. If the solution is at the upper bound, then the
function must be decreasing and <span class="math">\(\nabla f \leq 0\)</span>. If the solution
is strictly between the bounds, we must be at a stationary point and
<span class="math">\(\nabla f = 0\)</span>. Other complementarity problems arise in economics
and engineering <span id="id19">[<a class="reference internal" href="#id2688" title="M. C. Ferris and J. S. Pang. Engineering and economic applications of complementarity problems. SIAM Review, 39:669–713, 1997. URL: http: //www.siam.org/journals/sirev/39-4/28596.html.">FP97</a>]</span>, game theory
<span id="id20">[<a class="reference internal" href="#id3302" title="J. F. Nash. Equilibrium points in N–person games. Proceedings of the National Academy of Sciences, 36:48–49, 1950.">Nas50</a>]</span>, and finance
<span id="id21">[<a class="reference internal" href="#id2929" title="J. Huang and J. S. Pang. Option pricing and linear complementarity. Journal of Computational Finance, 2:31–60, 1998.">HP98</a>]</span>.</p>
<p>Evaluation routines for <span class="math">\(F\)</span> and its Jacobian must be supplied
prior to solving the application. The bounds, <span class="math">\([\ell,u]\)</span>, on the
variables must also be provided. If no starting point is supplied, a
default starting point of all zeros is used.</p>
<section id="semismooth-methods">
<h4>Semismooth Methods<a class="headerlink" href="#semismooth-methods" title="Permalink to this heading">#</a></h4>
<p>TAO has two implementations of semismooth algorithms
<span id="id22">[<a class="reference internal" href="#id3289" title="T. S. Munson, F. Facchinei, M. C. Ferris, A. Fischer, and C. Kanzow. The semismooth algorithm for large scale complementarity problems. INFORMS Journal on Computing, 2001.">MFF+01</a>]</span> <span id="id23">[<a class="reference internal" href="#id2556" title="T. De Luca, F. Facchinei, and C. Kanzow. A semismooth equation approach to the solution of nonlinear complementarity problems. Mathematical Programming, 75:407–439, 1996.">DeLucaFK96</a>]</span>
<span id="id24">[<a class="reference internal" href="#id2645" title="Francisco Facchinei, Andreas Fischer, and Christian Kanzow. A semismooth Newton method for variational inequalities: The case of box constraints. Complementarity and Variational Problems: State of the Art, 92:76, 1997.">FFK97</a>]</span> for solving mixed complementarity
problems. Both are based on a reformulation of the mixed complementarity
problem as a nonsmooth system of equations using the Fischer-Burmeister
function <span id="id25">[<a class="reference internal" href="#id2721" title="A. Fischer. A special Newton–type optimization method. Optimization, 24:269–284, 1992.">Fis92</a>]</span>. A nonsmooth Newton method
is applied to the reformulated system to calculate a solution. The
theoretical properties of such methods are detailed in the
aforementioned references.</p>
<p>The Fischer-Burmeister function, <span class="math">\(\phi:\mathbb R^2 \to \mathbb R\)</span>,
is defined as</p>
<div class="math">
\[\begin{aligned}
\phi(a,b) := \sqrt{a^2 + b^2} - a - b.\end{aligned}\]</div>
<p>This function has the following key property,</p>
<div class="math">
\[\begin{aligned}
\begin{array}{lcr}
        \phi(a,b) = 0 & \Leftrightarrow & a \geq 0,\; b \geq 0,\; ab = 0,
\end{array}\end{aligned}\]</div>
<p>used when reformulating the mixed complementarity problem as the system
of equations <span class="math">\(\Phi(x) = 0\)</span>, where
<span class="math">\(\Phi:\mathbb R^n \to \mathbb R^n\)</span>. The reformulation is defined
componentwise as</p>
<div class="math">
\[\begin{aligned}
\Phi_i(x) := \left\{ \begin{array}{ll}
   \phi(x_i - l_i, F_i(x)) & \text{if } -\infty < l_i < u_i = \infty, \\
   -\phi(u_i-x_i, -F_i(x)) & \text{if } -\infty = l_i < u_i < \infty, \\
   \phi(x_i - l_i, \phi(u_i - x_i, - F_i(x))) & \text{if } -\infty < l_i < u_i < \infty, \\
   -F_i(x) & \text{if } -\infty = l_i < u_i = \infty, \\
   l_i - x_i & \text{if } -\infty < l_i = u_i < \infty.
   \end{array} \right.\end{aligned}\]</div>
<p>We note that <span class="math">\(\Phi\)</span> is not differentiable everywhere but satisfies
a semismoothness property
<span id="id26">[<a class="reference internal" href="#id3252" title="R. Mifflin. Semismooth and semiconvex functions in constrained optimization. SIAM Journal on Control and Optimization, 15:957–972, 1977.">Mif77</a>]</span> <span id="id27">[<a class="reference internal" href="#id3442" title="L. Qi. Convergence analysis of some algorithms for solving nonsmooth equations. Mathematics of Operations Research, 18:227–244, 1993.">Qi93</a>]</span> <span id="id28">[<a class="reference internal" href="#id3441" title="L. Qi and J. Sun. A nonsmooth version of Newton's method. Mathematical Programming, 58:353–368, 1993.">QS93</a>]</span>.
Furthermore, the natural merit function,
<span class="math">\(\Psi(x) := \frac{1}{2} \| \Phi(x) \|_2^2\)</span>, is continuously
differentiable.</p>
<p>The two semismooth TAO solvers both solve the system <span class="math">\(\Phi(x) = 0\)</span>
by applying a nonsmooth Newton method with a line search. We calculate a
direction, <span class="math">\(d^k\)</span>, by solving the system
<span class="math">\(H^kd^k = -\Phi(x^k)\)</span>, where <span class="math">\(H^k\)</span> is an element of the
<span class="math">\(B\)</span>-subdifferential <span id="id29">[<a class="reference internal" href="#id3441" title="L. Qi and J. Sun. A nonsmooth version of Newton's method. Mathematical Programming, 58:353–368, 1993.">QS93</a>]</span> of
<span class="math">\(\Phi\)</span> at <span class="math">\(x^k\)</span>. If the direction calculated does not
satisfy a suitable descent condition, then we use the negative gradient
of the merit function, <span class="math">\(-\nabla \Psi(x^k)\)</span>, as the search
direction. A standard Armijo search
<span id="id30">[<a class="reference internal" href="#id2278" title="L. Armijo. Minimization of functions having Lipschitz-continuous first partial derivatives. Pacific Journal of Mathematics, 16:1–3, 1966.">Arm66</a>]</span> is used to find the new
iteration. Nonmonotone searches
<span id="id31">[<a class="reference internal" href="#id2852" title="L. Grippo, F. Lampariello, and S. Lucidi. A nonmonotone line search technique for Newton's method. SIAM Journal on Numerical Analysis, 23:707–716, 1986.">GLL86</a>]</span> are also available
by setting appropriate runtime options. See
<a class="reference internal" href="#sec-taolinesearch"><span class="std std-ref">Line Searches</span></a> for further details.</p>
<p>The first semismooth algorithm available in TAO is not guaranteed to
remain feasible with respect to the bounds, <span class="math">\([\ell, u]\)</span>, and is
termed an infeasible semismooth method. This method can be specified by
using the <code class="docutils literal notranslate"><span class="pre">tao_ssils</span></code> solver. In this case, the descent test used is
that</p>
<div class="math">
\[\begin{aligned}
\nabla \Psi(x^k)^Td^k \leq -\delta\| d^k \|^\rho.\end{aligned}\]</div>
<p>Both <span class="math">\(\delta &gt; 0\)</span> and <span class="math">\(\rho &gt; 2\)</span> can be modified by using
the runtime options <code class="docutils literal notranslate"><span class="pre">-tao_ssils_delta</span> <span class="pre">&lt;delta&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">-tao_ssils_rho</span> <span class="pre">&lt;rho&gt;</span></code>, respectively. By default,
<span class="math">\(\delta = 10^{-10}\)</span> and <span class="math">\(\rho = 2.1\)</span>.</p>
<p>An alternative is to remain feasible with respect to the bounds by using
a projected Armijo line search. This method can be specified by using
the <code class="docutils literal notranslate"><span class="pre">tao_ssfls</span></code> solver. The descent test used is the same as above
where the direction in this case corresponds to the first part of the
piecewise linear arc searched by the projected line search. Both
<span class="math">\(\delta &gt; 0\)</span> and <span class="math">\(\rho &gt; 2\)</span> can be modified by using the
runtime options <code class="docutils literal notranslate"><span class="pre">-tao_ssfls_delta</span> <span class="pre">&lt;delta&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">-tao_ssfls_rho</span> <span class="pre">&lt;rho&gt;</span></code> respectively. By default,
<span class="math">\(\delta = 10^{-10}\)</span> and <span class="math">\(\rho = 2.1\)</span>.</p>
<p>The recommended algorithm is the infeasible semismooth method,
<code class="docutils literal notranslate"><span class="pre">tao_ssils</span></code>, because of its strong global and local convergence
properties. However, if it is known that <span class="math">\(F\)</span> is not defined
outside of the box, <span class="math">\([\ell,u]\)</span>, perhaps because of the presence of
<span class="math">\(\log\)</span> functions, the feasibility-enforcing version of the
algorithm, <code class="docutils literal notranslate"><span class="pre">tao_ssfls</span></code>, is a reasonable alternative.</p>
</section>
<section id="active-set-methods">
<h4>Active-Set Methods<a class="headerlink" href="#active-set-methods" title="Permalink to this heading">#</a></h4>
<p>TAO also contained two active-set semismooth methods for solving
complementarity problems.  These methods solve a reduced system
constructed by block elimination of active constraints.  The
subdifferential in these cases enables this block elimination.</p>
<p>The first active-set semismooth algorithm available in TAO is not guaranteed to
remain feasible with respect to the bounds, <span class="math">\([\ell, u]\)</span>, and is
termed an infeasible active-set semismooth method. This method can be
specified by using the <code class="docutils literal notranslate"><span class="pre">tao_asils</span></code> solver.</p>
<p>An alternative is to remain feasible with respect to the bounds by using
a projected Armijo line search. This method can be specified by using
the <code class="docutils literal notranslate"><span class="pre">tao_asfls</span></code> solver.</p>
</section>
</section>
<section id="quadratic-solvers">
<h3>Quadratic Solvers<a class="headerlink" href="#quadratic-solvers" title="Permalink to this heading">#</a></h3>
<p>Quadratic solvers solve optimization problems of the form</p>
<div class="math">
\[\begin{array}{ll}
\displaystyle \min_{x} & \frac{1}{2}x^T Q x + c^T x \\
\text{subject to} & l \geq x \geq u
\end{array}\]</div>
<p>where the gradient and the Hessian of the objective are both constant.</p>
<section id="gradient-projection-conjugate-gradient-method-gpcg">
<h4>Gradient Projection Conjugate Gradient Method (GPCG)<a class="headerlink" href="#gradient-projection-conjugate-gradient-method-gpcg" title="Permalink to this heading">#</a></h4>
<p>The GPCG <span id="id32">[<a class="reference internal" href="#id2188" title="Jorge J. Moré and G. Toraldo. On the solution of large quadratic programming problems with bound constraints. SIOPT, 1:93–113, 1991.">MoreT91</a>]</span> algorithm is much like the
TRON algorithm, discussed in Section <a class="reference internal" href="#sec-tron"><span class="std std-ref">Trust-Region Newton Method (TRON)</span></a>, except that
it assumes that the objective function is quadratic and convex.
Therefore, it evaluates the function, gradient, and Hessian only once.
Since the objective function is quadratic, the algorithm does not use a
trust region. All the options that apply to TRON except for trust-region
options also apply to GPCG. It can be set by using the TAO solver
<code class="docutils literal notranslate"><span class="pre">tao_gpcg</span></code> or via the optio flag <code class="docutils literal notranslate"><span class="pre">-tao_type</span> <span class="pre">gpcg</span></code>.</p>
</section>
<section id="interior-point-newtons-method-bqpip">
<span id="sec-bqpip"></span><h4>Interior-Point Newton’s Method (BQPIP)<a class="headerlink" href="#interior-point-newtons-method-bqpip" title="Permalink to this heading">#</a></h4>
<p>The BQPIP algorithm is an interior-point method for bound constrained
quadratic optimization. It can be set by using the TAO solver of
<code class="docutils literal notranslate"><span class="pre">tao_bqpip</span></code> or via the option flag <code class="docutils literal notranslate"><span class="pre">-tao_type</span> <span class="pre">bgpip</span></code>. Since it
assumes the objective function is quadratic, it evaluates the function,
gradient, and Hessian only once. This method also requires the solution
of systems of linear equations, whose solver can be accessed and
modified with the command <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetKSP.html">TaoGetKSP</a>()</span></code>.</p>
</section>
</section>
<section id="legacy-and-contributed-solvers">
<h3>Legacy and Contributed Solvers<a class="headerlink" href="#legacy-and-contributed-solvers" title="Permalink to this heading">#</a></h3>
<section id="bundle-method-for-regularized-risk-minimization-bmrm">
<h4>Bundle Method for Regularized Risk Minimization (BMRM)<a class="headerlink" href="#bundle-method-for-regularized-risk-minimization-bmrm" title="Permalink to this heading">#</a></h4>
<p>BMRM is a numerical approach to optimizing an
unconstrained objective in the form of
<span class="math">\(f(x) + 0.5 * \lambda \| x \|^2\)</span>. Here <span class="math">\(f\)</span> is a convex
function that is finite on the whole space. <span class="math">\(\lambda\)</span> is a
positive weight parameter, and <span class="math">\(\| x \|\)</span> is the Euclidean norm of
<span class="math">\(x\)</span>. The algorithm only requires a routine which, given an
<span class="math">\(x\)</span>, returns the value of <span class="math">\(f(x)\)</span> and the gradient of
<span class="math">\(f\)</span> at <span class="math">\(x\)</span>.</p>
</section>
<section id="orthant-wise-limited-memory-quasi-newton-owlqn">
<h4>Orthant-Wise Limited-memory Quasi-Newton (OWLQN)<a class="headerlink" href="#orthant-wise-limited-memory-quasi-newton-owlqn" title="Permalink to this heading">#</a></h4>
<p>OWLQN <span id="id33">[<a class="reference internal" href="#id2192" title="Galen Andrew and Jianfeng Gao. Scalable training of l1-regularized log-linear models. In Proceedings of the 24th international conference on Machine learning (ICML), 33–40. 2007.">AG07</a>]</span> is a numerical approach to optimizing
an unconstrained objective in the form of
<span class="math">\(f(x) + \lambda \|x\|_1\)</span>. Here f is a convex and differentiable
function, <span class="math">\(\lambda\)</span> is a positive weight parameter, and
<span class="math">\(\| x \|_1\)</span> is the <span class="math">\(\ell_1\)</span> norm of <span class="math">\(x\)</span>:
<span class="math">\(\sum_i |x_i|\)</span>. The algorithm only requires evaluating the value
of <span class="math">\(f\)</span> and its gradient.</p>
</section>
<section id="trust-region-newton-method-tron">
<span id="sec-tron"></span><h4>Trust-Region Newton Method (TRON)<a class="headerlink" href="#trust-region-newton-method-tron" title="Permalink to this heading">#</a></h4>
<p>The TRON <span id="id34">[<a class="reference internal" href="#id2190" title="C.-J. Lin and J. J. Moré. Newton's method for large bound-constrained optimization problems. SIOPT, 9(4):1100–1127, 1999. URL: http://www.mcs.anl.gov/home/more/papers/nb.ps.gz.">LMore99</a>]</span> algorithm is an active-set method
that uses a combination of gradient projections and a preconditioned
conjugate gradient method to minimize an objective function. Each
iteration of the TRON algorithm requires function, gradient, and Hessian
evaluations. In each iteration, the algorithm first applies several
conjugate gradient iterations. After these iterates, the TRON solver
momentarily ignores the variables that equal one of its bounds and
applies a preconditioned conjugate gradient method to a quadratic model
of the remaining set of <em>free</em> variables.</p>
<p>The TRON algorithm solves a reduced linear system defined by the rows
and columns corresponding to the variables that lie between the upper
and lower bounds. The TRON algorithm applies a trust region to the
conjugate gradients to ensure convergence. The initial trust-region
radius can be set by using the command
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetInitialTrustRegionRadius.html">TaoSetInitialTrustRegionRadius</a>()</span></code>, and the current trust region size
can be found by using the command <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetCurrentTrustRegionRadius.html">TaoGetCurrentTrustRegionRadius</a>()</span></code>.
The initial trust region can significantly alter the rate of convergence
for the algorithm and should be tuned and adjusted for optimal
performance.</p>
<p>This algorithm will be deprecated in the next version in favor of the
Bounded Newton Trust Region (BNTR) algorithm.</p>
</section>
<section id="bound-constrained-limited-memory-variable-metric-method-blmvm">
<span id="sec-blmvm"></span><h4>Bound-constrained Limited-Memory Variable-Metric Method (BLMVM)<a class="headerlink" href="#bound-constrained-limited-memory-variable-metric-method-blmvm" title="Permalink to this heading">#</a></h4>
<p>BLMVM is a limited-memory, variable-metric method and is the
bound-constrained variant of the LMVM method for unconstrained
optimization. It uses projected gradients to approximate the Hessian,
eliminating the need for Hessian evaluations. The method can be set by
using the TAO solver <code class="docutils literal notranslate"><span class="pre">tao_blmvm</span></code>. For more details, please see the
LMVM section in the unconstrained algorithms as well as the LMVM matrix
documentation in the PETSc manual.</p>
<p>This algorithm will be deprecated in the next version in favor of the
Bounded Quasi-Newton Line Search (BQNLS) algorithm.</p>
</section>
</section>
</section>
<section id="advanced-options">
<h2>Advanced Options<a class="headerlink" href="#advanced-options" title="Permalink to this heading">#</a></h2>
<p>This section discusses options and routines that apply to most TAO
solvers and problem classes. In particular, we focus on linear solvers,
convergence tests, and line searches.</p>
<section id="linear-solvers">
<span id="sec-taolinearsolvers"></span><h3>Linear Solvers<a class="headerlink" href="#linear-solvers" title="Permalink to this heading">#</a></h3>
<p>One of the most computationally intensive phases of many optimization
algorithms involves the solution of linear systems of equations. The
performance of the linear solver may be critical to an efficient
computation of the solution. Since linear equation solvers often have a
wide variety of options associated with them, TAO allows the user to
access the linear solver with the</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetKSP.html">TaoGetKSP</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/KSP/KSP.html">KSP</a></span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>command. With access to the KSP object, users can customize it for their
application to achieve improved performance. Additional details on the
KSP options in PETSc can be found in the <a class="reference internal" href="index.html"><span class="doc">User-Guide</span></a>.</p>
</section>
<section id="monitors">
<h3>Monitors<a class="headerlink" href="#monitors" title="Permalink to this heading">#</a></h3>
<p>By default the TAO solvers run silently without displaying information
about the iterations. The user can initiate monitoring with the command</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetMonitor.html">TaoSetMonitor</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mon</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>The routine <code class="docutils literal notranslate"><span class="pre">mon</span></code> indicates a user-defined monitoring routine, and
<code class="docutils literal notranslate"><span class="pre">void*</span></code> denotes an optional user-defined context for private data for
the monitor routine.</p>
<p>The routine set by <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetMonitor.html">TaoSetMonitor</a>()</span></code> is called once during each
iteration of the optimization solver. Hence, the user can employ this
routine for any application-specific computations that should be done
after the solution update.</p>
</section>
<section id="convergence-tests">
<span id="sec-taoconvergence"></span><h3>Convergence Tests<a class="headerlink" href="#convergence-tests" title="Permalink to this heading">#</a></h3>
<p>Convergence of a solver can be defined in many ways. The methods TAO
uses by default are mentioned in <a class="reference internal" href="#sec-customize"><span class="std std-ref">Convergence</span></a>.
These methods include absolute and relative convergence tolerances as
well as a maximum number of iterations of function evaluations. If these
choices are not sufficient, the user can specify a customized test</p>
<p>Users can set their own customized convergence tests of the form</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w">  </span><span class="nf">conv</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>The second argument is a pointer to a structure defined by the user.
Within this routine, the solver can be queried for the solution vector,
gradient vector, or other statistic at the current iteration through
routines such as <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetSolutionStatus.html">TaoGetSolutionStatus</a>()</span></code> and <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoGetTolerances.html">TaoGetTolerances</a>()</span></code>.</p>
<p>To use this convergence test within a TAO solver, one uses the command</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetConvergenceTest.html">TaoSetConvergenceTest</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">conv</span><span class="p">)(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</pre></div>
</div>
<p>The second argument of this command is the convergence routine, and the
final argument of the convergence test routine denotes an optional
user-defined context for private data. The convergence routine receives
the TAO solver and this private data structure. The termination flag can
be set by using the routine</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetConvergedReason.html">TaoSetConvergedReason</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoConvergedReason.html">TaoConvergedReason</a></span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="line-searches">
<span id="sec-taolinesearch"></span><h3>Line Searches<a class="headerlink" href="#line-searches" title="Permalink to this heading">#</a></h3>
<p>By using the command line option <code class="docutils literal notranslate"><span class="pre">-tao_ls_type</span></code>. Available line
searches include Moré-Thuente <span id="id35">[<a class="reference internal" href="#id2187" title="Jorge J. Moré and David Thuente. Line search algorithms with guaranteed sufficient decrease. Technical Report MCS-P330-1092, Mathematics and Computer Science Division, Argonne National Laboratory, 1992.">MoreT92</a>]</span>, Armijo, gpcg,
and unit.</p>
<p>The line search routines involve several parameters, which are set to
defaults that are reasonable for many applications. The user can
override the defaults by using the following options</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">-tao_ls_max_funcs</span> <span class="pre">&lt;max&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-tao_ls_stepmin</span> <span class="pre">&lt;min&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-tao_ls_stepmax</span> <span class="pre">&lt;max&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-tao_ls_ftol</span> <span class="pre">&lt;ftol&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-tao_ls_gtol</span> <span class="pre">&lt;gtol&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-tao_ls_rtol</span> <span class="pre">&lt;rtol&gt;</span></code></p></li>
</ul>
<p>One should run a TAO program with the option <code class="docutils literal notranslate"><span class="pre">-help</span></code> for details.
Users may write their own customized line search codes by modeling them
after one of the defaults provided.</p>
</section>
<section id="recycling-history">
<span id="sec-taorecyclehistory"></span><h3>Recycling History<a class="headerlink" href="#recycling-history" title="Permalink to this heading">#</a></h3>
<p>Some TAO algorithms can re-use information accumulated in the previous
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a>()</span></code> call to hot-start the new solution. This can be enabled
using the <code class="docutils literal notranslate"><span class="pre">-tao_recycle_history</span></code> flag, or in code via the
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetRecycleHistory.html">TaoSetRecycleHistory</a>()</span></code> interface.</p>
<p>For the nonlinear conjugate gradient solver (<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAOBNCG.html">TAOBNCG</a></span></code>), this option
re-uses the latest search direction from the previous <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a>()</span></code>
call to compute the initial search direction of a new <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a>()</span></code>. By
default, the feature is disabled and the algorithm sets the initial
direction as the negative gradient.</p>
<p>For the quasi-Newton family of methods (<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAOBQNLS.html">TAOBQNLS</a></span></code>, <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAOBQNKLS.html">TAOBQNKLS</a></span></code>,
<code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAOBQNKTR.html">TAOBQNKTR</a></span></code>, <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TAOBQNKTL.html">TAOBQNKTL</a></span></code>), this option re-uses the accumulated
quasi-Newton Hessian approximation from the previous <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a>()</span></code>
call. By default, the feature is disabled and the algorithm will reset
the quasi-Newton approximation to the identity matrix at the beginning
of every new <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a>()</span></code>.</p>
<p>The option flag has no effect on other TAO solvers.</p>
</section>
</section>
<section id="adding-a-solver">
<span id="sec-tao-addsolver"></span><h2>Adding a Solver<a class="headerlink" href="#adding-a-solver" title="Permalink to this heading">#</a></h2>
<p>One of the strengths of both TAO and PETSc is the ability to allow users
to extend the built-in solvers with new user-defined algorithms. It is
certainly possible to develop new optimization algorithms outside of TAO
framework, but Using TAO to implement a solver has many advantages,</p>
<ol class="arabic simple">
<li><p>TAO includes other optimization solvers with an identical interface,
so application problems may conveniently switch solvers to compare
their effectiveness.</p></li>
<li><p>TAO provides support for function evaluations and derivative
information. It allows for the direct evaluation of this information
by the application developer, contains limited support for finite
difference approximations, and allows the uses of matrix-free
methods. The solvers can obtain this function and derivative
information through a simple interface while the details of its
computation are handled within the toolkit.</p></li>
<li><p>TAO provides line searches, convergence tests, monitoring routines,
and other tools that are helpful in an optimization algorithm. The
availability of these tools means that the developers of the
optimization solver do not have to write these utilities.</p></li>
<li><p>PETSc offers vectors, matrices, index sets, and linear solvers that
can be used by the solver. These objects are standard mathematical
constructions that have many different implementations. The objects
may be distributed over multiple processors, restricted to a single
processor, have a dense representation, use a sparse data structure,
or vary in many other ways. TAO solvers do not need to know how these
objects are represented or how the operations defined on them have
been implemented. Instead, the solvers apply these operations through
an abstract interface that leaves the details to PETSc and external
libraries. This abstraction allows solvers to work seamlessly with a
variety of data structures while allowing application developers to
select data structures tailored for their purposes.</p></li>
<li><p>PETSc provides the user a convenient method for setting options at
runtime, performance profiling, and debugging.</p></li>
</ol>
<section id="header-file-1">
<span id="id36"></span><h3>Header File<a class="headerlink" href="#header-file-1" title="Permalink to this heading">#</a></h3>
<p>TAO solver implementation files must include the TAO implementation file
<code class="docutils literal notranslate"><span class="pre">taoimpl.h</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;petsc/private/taoimpl.h&quot;</span>
</pre></div>
</div>
<p>This file contains data elements that are generally kept hidden from
application programmers, but may be necessary for solver implementations
to access.</p>
</section>
<section id="tao-interface-with-solvers">
<h3>TAO Interface with Solvers<a class="headerlink" href="#tao-interface-with-solvers" title="Permalink to this heading">#</a></h3>
<p>TAO solvers must be written in C or C++ and include several routines
with a particular calling sequence. Two of these routines are mandatory:
one that initializes the TAO structure with the appropriate information
and one that applies the algorithm to a problem instance. Additional
routines may be written to set options within the solver, view the
solver, setup appropriate data structures, and destroy these data
structures. In order to implement the conjugate gradient algorithm, for
example, the following structure is useful.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="p">{</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w"> </span><span class="n">beta</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w"> </span><span class="n">eta</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscInt.html">PetscInt</a></span><span class="w">  </span><span class="n">ngradtseps</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscInt.html">PetscInt</a></span><span class="w">  </span><span class="n">nresetsteps</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w"> </span><span class="n">X_old</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w"> </span><span class="n">G_old</span><span class="p">;</span>

<span class="p">}</span><span class="w"> </span><span class="n">TAO_CG</span><span class="p">;</span>
</pre></div>
</div>
<p>This structure contains two parameters, two counters, and two work
vectors. Vectors for the solution and gradient are not needed here
because the TAO structure has pointers to them.</p>
<section id="solver-routine">
<h4>Solver Routine<a class="headerlink" href="#solver-routine" title="Permalink to this heading">#</a></h4>
<p>All TAO solvers have a routine that accepts a TAO structure and computes
a solution. TAO will call this routine when the application program uses
the routine <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a>()</span></code> and will pass to the solver information about
the objective function and constraints, pointers to the variable vector
and gradient vector, and support for line searches, linear solvers, and
convergence monitoring. As an example, consider the following code that
solves an unconstrained minimization problem using the conjugate
gradient method.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">TaoSolve_CG</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">TAO_CG</span><span class="w">  </span><span class="o">*</span><span class="n">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TAO_CG</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">solution</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">gradient</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">stepdirection</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscInt.html">PetscInt</a></span><span class="w">     </span><span class="n">iter</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w">  </span><span class="n">gnormPrev</span><span class="p">,</span><span class="n">gdx</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">gnorm</span><span class="p">,</span><span class="n">steplength</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoLineSearchConvergedReason.html">TaoLineSearchConvergedReason</a></span><span class="w"> </span><span class="n">lsflag</span><span class="o">=</span><span class="n">TAO_LINESEARCH_CONTINUE_ITERATING</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoConvergedReason.html">TaoConvergedReason</a></span><span class="w"> </span><span class="n">reason</span><span class="o">=</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoConvergedReason.html">TAO_CONTINUE_ITERATING</a></span><span class="p">;</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionBegin.html">PetscFunctionBegin</a></span><span class="p">;</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoComputeObjectiveAndGradient.html">TaoComputeObjectiveAndGradient</a></span><span class="p">(</span><span class="n">tao</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecNorm.html">VecNorm</a></span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/NORM_2.html">NORM_2</a></span><span class="p">,</span><span class="o">&amp;</span><span class="n">gnorm</span><span class="p">));</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecSet.html">VecSet</a></span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>

<span class="w">  </span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">beta</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">gnormPrev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gnorm</span><span class="p">;</span>

<span class="w">  </span><span class="cm">/* Enter loop */</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>

<span class="w">    </span><span class="cm">/* Test for convergence */</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoMonitor.html">TaoMonitor</a></span><span class="p">(</span><span class="n">tao</span><span class="p">,</span><span class="n">iter</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="n">gnorm</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="n">step</span><span class="p">,</span><span class="o">&amp;</span><span class="n">reason</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">reason</span><span class="o">!=</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoConvergedReason.html">TAO_CONTINUE_ITERATING</a></span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">beta</span><span class="o">=</span><span class="p">(</span><span class="n">gnorm</span><span class="o">*</span><span class="n">gnorm</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">gnormPrev</span><span class="o">*</span><span class="n">gnormPrev</span><span class="p">);</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecScale.html">VecScale</a></span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">beta</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecAXPY.html">VecAXPY</a></span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mf">-1.0</span><span class="p">,</span><span class="n">g</span><span class="p">));</span>

<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDot.html">VecDot</a></span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="o">&amp;</span><span class="n">gdx</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">gdx</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">){</span><span class="w">     </span><span class="cm">/* If not a descent direction, use gradient */</span>
<span class="w">      </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecCopy.html">VecCopy</a></span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n">s</span><span class="p">));</span>
<span class="w">      </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecScale.html">VecScale</a></span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mf">-1.0</span><span class="p">));</span>
<span class="w">      </span><span class="n">gdx</span><span class="o">=-</span><span class="n">gnorm</span><span class="o">*</span><span class="n">gnorm</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Line Search */</span>
<span class="w">    </span><span class="n">gnormPrev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gnorm</span><span class="p">;</span><span class="w">  </span><span class="n">step</span><span class="o">=</span><span class="mf">1.0</span><span class="p">;</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/TaoLineSearch/TaoLineSearchSetInitialStepLength.html">TaoLineSearchSetInitialStepLength</a></span><span class="p">(</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">linesearch</span><span class="p">,</span><span class="mf">1.0</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/TaoLineSearch/TaoLineSearchApply.html">TaoLineSearchApply</a></span><span class="p">(</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">linesearch</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="o">&amp;</span><span class="n">f</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="o">&amp;</span><span class="n">steplength</span><span class="p">,</span><span class="o">&amp;</span><span class="n">lsflag</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoAddLineSearchCounts.html">TaoAddLineSearchCounts</a></span><span class="p">(</span><span class="n">tao</span><span class="p">));</span>
<span class="w">    </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecNorm.html">VecNorm</a></span><span class="p">(</span><span class="n">g</span><span class="p">,</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/NORM_2.html">NORM_2</a></span><span class="p">,</span><span class="o">&amp;</span><span class="n">gnorm</span><span class="p">));</span>
<span class="w">    </span><span class="n">iter</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionReturn.html">PetscFunctionReturn</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PETSC_SUCCESS</a></span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The first line of this routine casts the second argument to a pointer to
a <code class="docutils literal notranslate"><span class="pre">TAO_CG</span></code> data structure. This structure contains pointers to three
vectors and a scalar that will be needed in the algorithm.</p>
<p>After declaring an initializing several variables, the solver lets TAO
evaluate the function and gradient at the current point in the using the
routine <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoComputeObjectiveAndGradient.html">TaoComputeObjectiveAndGradient</a>()</span></code>. Other routines may be used
to evaluate the Hessian matrix or evaluate constraints. TAO may obtain
this information using direct evaluation or other means, but these
details do not affect our implementation of the algorithm.</p>
<p>The norm of the gradient is a standard measure used by unconstrained
minimization solvers to define convergence. This quantity is always
nonnegative and equals zero at the solution. The solver will pass this
quantity, the current function value, the current iteration number, and
a measure of infeasibility to TAO with the routine</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoMonitor.html">TaoMonitor</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscInt.html">PetscInt</a></span><span class="w"> </span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w"> </span><span class="n">f</span><span class="p">,</span>
<span class="w">               </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w"> </span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w"> </span><span class="n">cnorm</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w"> </span><span class="n">steplength</span><span class="p">,</span>
<span class="w">               </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoConvergedReason.html">TaoConvergedReason</a></span><span class="w"> </span><span class="o">*</span><span class="n">reason</span><span class="p">);</span>
</pre></div>
</div>
<p>Most optimization algorithms are iterative, and solvers should include
this command somewhere in each iteration. This routine records this
information, and applies any monitoring routines and convergence tests
set by default or the user. In this routine, the second argument is the
current iteration number, and the third argument is the current function
value. The fourth argument is a nonnegative error measure associated
with the distance between the current solution and the optimal solution.
Examples of this measure are the norm of the gradient or the square root
of a duality gap. The fifth argument is a nonnegative error that usually
represents a measure of the infeasibility such as the norm of the
constraints or violation of bounds. This number should be zero for
unconstrained solvers. The sixth argument is a nonnegative steplength,
or the multiple of the step direction added to the previous iterate. The
results of the convergence test are returned in the last argument. If
the termination reason is <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoConvergedReason.html">TAO_CONTINUE_ITERATING</a></span></code>, the algorithm
should continue.</p>
<p>After this monitoring routine, the solver computes a step direction
using the conjugate gradient algorithm and computations using Vec
objects. These methods include adding vectors together and computing an
inner product. A full list of these methods can be found in the manual
pages.</p>
<p>Nonlinear conjugate gradient algorithms also require a line search. TAO
provides several line searches and support for using them. The routine</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/TaoLineSearch/TaoLineSearchApply.html">TaoLineSearchApply</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoLineSearch.html">TaoLineSearch</a></span><span class="w"> </span><span class="n">ls</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/Vec.html">Vec</a></span><span class="w"> </span><span class="n">g</span><span class="p">,</span>
<span class="w">                       </span><span class="n">TaoVec</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscReal.html">PetscReal</a></span><span class="w"> </span><span class="o">*</span><span class="n">steplength</span><span class="p">,</span>
<span class="w">                       </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoLineSearchConvergedReason.html">TaoLineSearchConvergedReason</a></span><span class="w"> </span><span class="o">*</span><span class="n">lsflag</span><span class="p">)</span>
</pre></div>
</div>
<p>passes the current solution, gradient, and objective value to the line
search and returns a new solution, gradient, and objective value. More
details on line searches can be found in
<a class="reference internal" href="#sec-taolinesearch"><span class="std std-ref">Line Searches</span></a>. The details of the
line search applied are specified elsewhere, when the line search is
created.</p>
<p>TAO also includes support for linear solvers using PETSc KSP objects.
Although this algorithm does not require one, linear solvers are an
important part of many algorithms. Details on the use of these solvers
can be found in the PETSc users manual.</p>
</section>
<section id="creation-routine">
<h4>Creation Routine<a class="headerlink" href="#creation-routine" title="Permalink to this heading">#</a></h4>
<p>The TAO solver is initialized for a particular algorithm in a separate
routine. This routine sets default convergence tolerances, creates a
line search or linear solver if needed, and creates structures needed by
this solver. For example, the routine that creates the nonlinear
conjugate gradient algorithm shown above can be implemented as follows.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PETSC_EXTERN</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="n">TaoCreate_CG</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">TAO_CG</span><span class="w"> </span><span class="o">*</span><span class="n">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TAO_CG</span><span class="o">*</span><span class="p">)</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">morethuente_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TAOLINESEARCH_MT</span><span class="p">;</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionBegin.html">PetscFunctionBegin</a></span><span class="p">;</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscNew.html">PetscNew</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="p">));</span>
<span class="w">  </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">cg</span><span class="p">;</span>
<span class="w">  </span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">eta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span>
<span class="w">  </span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">delta_min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1e-7</span><span class="p">;</span>
<span class="w">  </span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">delta_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span>
<span class="w">  </span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">cg_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CG_PolakRibierePlus</span><span class="p">;</span>

<span class="w">  </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">max_it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2000</span><span class="p">;</span>
<span class="w">  </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">max_funcs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4000</span><span class="p">;</span>

<span class="w">  </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">setup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TaoSetUp_CG</span><span class="p">;</span>
<span class="w">  </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">solve</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TaoSolve_CG</span><span class="p">;</span>
<span class="w">  </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TaoView_CG</span><span class="p">;</span>
<span class="w">  </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">setfromoptions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TaoSetFromOptions_CG</span><span class="p">;</span>
<span class="w">  </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">destroy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TaoDestroy_CG</span><span class="p">;</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/TaoLineSearch/TaoLineSearchCreate.html">TaoLineSearchCreate</a></span><span class="p">(((</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscObject.html">PetscObject</a></span><span class="p">)</span><span class="n">tao</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">linesearch</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/TaoLineSearch/TaoLineSearchSetType.html">TaoLineSearchSetType</a></span><span class="p">(</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">linesearch</span><span class="p">,</span><span class="w"> </span><span class="n">morethuente_type</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/TaoLineSearch/TaoLineSearchUseTaoRoutines.html">TaoLineSearchUseTaoRoutines</a></span><span class="p">(</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">linesearch</span><span class="p">,</span><span class="w"> </span><span class="n">tao</span><span class="p">));</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionReturn.html">PetscFunctionReturn</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PETSC_SUCCESS</a></span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXTERN_C_END</span>
</pre></div>
</div>
<p>This routine declares some variables and then allocates memory for the
<code class="docutils literal notranslate"><span class="pre">TAO_CG</span></code> data structure. Notice that the <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span></code> object now has a
pointer to this data structure (<code class="docutils literal notranslate"><span class="pre">tao-&gt;data</span></code>) so it can be accessed by
the other functions written for this solver implementation.</p>
<p>This routine also sets some default parameters particular to the
conjugate gradient algorithm, sets default convergence tolerances, and
creates a particular line search. These defaults could be specified in
the routine that solves the problem, but specifying them here gives the
user the opportunity to modify these parameters either by using direct
calls setting parameters or by using options.</p>
<p>Finally, this solver passes to TAO the names of all the other routines
used by the solver.</p>
<p>Note that the lines <code class="docutils literal notranslate"><span class="pre">EXTERN_C_BEGIN</span></code> and <code class="docutils literal notranslate"><span class="pre">EXTERN_C_END</span></code> surround
this routine. These macros are required to preserve the name of this
function without any name-mangling from the C++ compiler (if used).</p>
</section>
<section id="destroy-routine">
<h4>Destroy Routine<a class="headerlink" href="#destroy-routine" title="Permalink to this heading">#</a></h4>
<p>Another routine needed by most solvers destroys the data structures
created by earlier routines. For the nonlinear conjugate gradient method
discussed earlier, the following routine destroys the two work vectors
and the <code class="docutils literal notranslate"><span class="pre">TAO_CG</span></code> structure.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">TaoDestroy_CG</span><span class="p">(</span><span class="n">TAO_SOLVER</span><span class="w"> </span><span class="n">tao</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">TAO_CG</span><span class="w"> </span><span class="o">*</span><span class="n">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TAO_CG</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionBegin.html">PetscFunctionBegin</a></span><span class="p">;</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDestroy.html">VecDestroy</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">X_old</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDestroy.html">VecDestroy</a></span><span class="p">(</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">G_old</span><span class="p">));</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFree.html">PetscFree</a></span><span class="p">(</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="w">  </span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionReturn.html">PetscFunctionReturn</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PETSC_SUCCESS</a></span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This routine is called from within the <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoDestroy.html">TaoDestroy</a>()</span></code> routine. Only
algorithm-specific data objects are destroyed in this routine; any
objects indexed by TAO (<code class="docutils literal notranslate"><span class="pre">tao-&gt;linesearch</span></code>, <code class="docutils literal notranslate"><span class="pre">tao-&gt;ksp</span></code>,
<code class="docutils literal notranslate"><span class="pre">tao-&gt;gradient</span></code>, etc.) will be destroyed by TAO immediately after the
algorithm-specific destroy routine completes.</p>
</section>
<section id="setup-routine">
<h4>SetUp Routine<a class="headerlink" href="#setup-routine" title="Permalink to this heading">#</a></h4>
<p>If the SetUp routine has been set by the initialization routine, TAO
will call it during the execution of <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSolve.html">TaoSolve</a>()</span></code>. While this routine
is optional, it is often provided to allocate the gradient vector, work
vectors, and other data structures required by the solver. It should
have the following form.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">TaoSetUp_CG</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">TAO_CG</span><span class="w"> </span><span class="o">*</span><span class="n">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TAO_CG</span><span class="o">*</span><span class="p">)</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionBegin.html">PetscFunctionBegin</a></span><span class="p">;</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDuplicate.html">VecDuplicate</a></span><span class="p">(</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">solution</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">gradient</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDuplicate.html">VecDuplicate</a></span><span class="p">(</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">solution</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">stepdirection</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDuplicate.html">VecDuplicate</a></span><span class="p">(</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">solution</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">X_old</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Vec/VecDuplicate.html">VecDuplicate</a></span><span class="p">(</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">solution</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">G_old</span><span class="p">));</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionReturn.html">PetscFunctionReturn</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PETSC_SUCCESS</a></span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="setfromoptions-routine">
<h4>SetFromOptions Routine<a class="headerlink" href="#setfromoptions-routine" title="Permalink to this heading">#</a></h4>
<p>The SetFromOptions routine should be used to check for any
algorithm-specific options set by the user and will be called when the
application makes a call to <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetFromOptions.html">TaoSetFromOptions</a>()</span></code>. It should have the
following form.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">TaoSetFromOptions_CG</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">solver</span><span class="p">);</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">TAO_CG</span><span class="w"> </span><span class="o">*</span><span class="n">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TAO_CG</span><span class="o">*</span><span class="p">)</span><span class="n">solver</span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionBegin.html">PetscFunctionBegin</a></span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscOptionsReal.html">PetscOptionsReal</a></span><span class="p">(</span><span class="s">&quot;-tao_cg_eta&quot;</span><span class="p">,</span><span class="s">&quot;restart tolerance&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">eta</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">eta</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscOptionsReal.html">PetscOptionsReal</a></span><span class="p">(</span><span class="s">&quot;-tao_cg_delta_min&quot;</span><span class="p">,</span><span class="s">&quot;minimum delta value&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">delta_min</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">delta_min</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscOptionsReal.html">PetscOptionsReal</a></span><span class="p">(</span><span class="s">&quot;-tao_cg_delta_max&quot;</span><span class="p">,</span><span class="s">&quot;maximum delta value&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">delta_max</span><span class="p">,</span><span class="o">&amp;</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">delta_max</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionReturn.html">PetscFunctionReturn</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PETSC_SUCCESS</a></span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="view-routine">
<h4>View Routine<a class="headerlink" href="#view-routine" title="Permalink to this heading">#</a></h4>
<p>The View routine should be used to output any algorithm-specific
information or statistics at the end of a solve. This routine will be
called when the application makes a call to <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoView.html">TaoView</a>()</span></code> or when the
command line option <code class="docutils literal notranslate"><span class="pre">-tao_view</span></code> is used. It should have the following
form.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="nf">TaoView_CG</span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="w"> </span><span class="n">tao</span><span class="p">,</span><span class="w"> </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Viewer/PetscViewer.html">PetscViewer</a></span><span class="w"> </span><span class="n">viewer</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">TAO_CG</span><span class="w"> </span><span class="o">*</span><span class="n">cg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">TAO_CG</span><span class="o">*</span><span class="p">)</span><span class="n">tao</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionBegin.html">PetscFunctionBegin</a></span><span class="p">;</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Viewer/PetscViewerASCIIPushTab.html">PetscViewerASCIIPushTab</a></span><span class="p">(</span><span class="n">viewer</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Viewer/PetscViewerASCIIPrintf.html">PetscViewerASCIIPrintf</a></span><span class="p">(</span><span class="n">viewer</span><span class="p">,</span><span class="s">&quot;Grad. steps: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">ngradsteps</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Viewer/PetscViewerASCIIPrintf.html">PetscViewerASCIIPrintf</a></span><span class="p">(</span><span class="n">viewer</span><span class="p">,</span><span class="s">&quot;Reset steps: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">cg</span><span class="o">-&gt;</span><span class="n">nresetsteps</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscCall.html">PetscCall</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Viewer/PetscViewerASCIIPopTab.html">PetscViewerASCIIPopTab</a></span><span class="p">(</span><span class="n">viewer</span><span class="p">));</span>
<span class="w">  </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscFunctionReturn.html">PetscFunctionReturn</a></span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PETSC_SUCCESS</a></span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="registering-the-solver">
<h4>Registering the Solver<a class="headerlink" href="#registering-the-solver" title="Permalink to this heading">#</a></h4>
<p>Once a new solver is implemented, TAO needs to know the name of the
solver and what function to use to create the solver. To this end, one
can use the routine</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoRegister.html">TaoRegister</a></span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">path</span><span class="p">,</span>
<span class="w">                </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">cname</span><span class="p">,</span>
<span class="w">                </span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Sys/PetscErrorCode.html">PetscErrorCode</a></span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/Tao.html">Tao</a></span><span class="p">));</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name of the solver (i.e., <code class="docutils literal notranslate"><span class="pre">tao_blmvm</span></code>), <code class="docutils literal notranslate"><span class="pre">path</span></code>
is the path to the library containing the solver, <code class="docutils literal notranslate"><span class="pre">cname</span></code> is the name
of the routine that creates the solver (in our case, <code class="docutils literal notranslate"><span class="pre">TaoCreate_CG</span></code>),
and <code class="docutils literal notranslate"><span class="pre">create</span></code> is a pointer to that creation routine. If one is using
dynamic loading, then the fourth argument will be ignored.</p>
<p>Once the solver has been registered, the new solver can be selected
either by using the <code class="docutils literal notranslate"><span class="pre"><a href="PETSC_DOC_OUT_ROOT_PLACEHOLDER/manualpages/Tao/TaoSetType.html">TaoSetType</a>()</span></code> function or by using the
<code class="docutils literal notranslate"><span class="pre">-tao_type</span></code> command line option.</p>
<p class="rubric">Footnotes</p>
<dl class="footnote brackets">
<dt class="label" id="mpi"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>For more on MPI and PETSc, see <a class="reference internal" href="getting_started.html#sec-running"><span class="std std-ref">Running PETSc Programs</span></a>.</p>
</dd>
</dl>
<div class="docutils container" id="id37">
<dl class="citation">
<dt class="label" id="id2192"><span class="brackets"><a class="fn-backref" href="#id33">AG07</a></span></dt>
<dd><p>Galen Andrew and Jianfeng Gao. Scalable training of l1-regularized log-linear models. In <em>Proceedings of the 24th international conference on Machine learning (ICML)</em>, 33–40. 2007.</p>
</dd>
<dt class="label" id="id2278"><span class="brackets"><a class="fn-backref" href="#id30">Arm66</a></span></dt>
<dd><p>L. Armijo. Minimization of functions having Lipschitz-continuous first partial derivatives. <em>Pacific Journal of Mathematics</em>, 16:1–3, 1966.</p>
</dd>
<dt class="label" id="id2343"><span class="brackets"><a class="fn-backref" href="#id6">Ber82</a></span></dt>
<dd><p>Dimitri P. Bertsekas. Projected Newton methods for optimization problems with simple constraints. <em>SIAM Journal on Control and Optimization</em>, 20:221–246, 1982.</p>
</dd>
<dt class="label" id="id2214"><span class="brackets"><a class="fn-backref" href="#id7">BPC+11</a></span></dt>
<dd><p>Stephen Boyd, Neal Parikh, Eric Chu, Borja Peleato, Jonathan Eckstein, and others. Distributed optimization and statistical learning via the alternating direction method of multipliers. <em>Foundations and Trends® in Machine learning</em>, 3(1):1–122, 2011.</p>
</dd>
<dt class="label" id="id2499"><span class="brackets">CGT00</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p>A. R. Conn, N. I. M. Gould, and Ph. L. Toint. <em>Trust-Region Methods</em>. SIAM, Philadelphia, Pennsylvania, 2000.</p>
</dd>
<dt class="label" id="id3783"><span class="brackets"><a class="fn-backref" href="#id13">CSV09</a></span></dt>
<dd><p>Andrew R. Conn, Katya Scheinberg, and Luís N. Vicente. <em>Introduction to Derivative-Free Optimization</em>. MPS/SIAM Series on Optimization. Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 2009. ISBN 0-89871-460-5.</p>
</dd>
<dt class="label" id="id2514"><span class="brackets"><a class="fn-backref" href="#id16">Cot64</a></span></dt>
<dd><p>R. W. Cottle. <em>Nonlinear programs with positively bounded Jacobians</em>. PhD thesis, Department of Mathematics, University of California, Berkeley, California, 1964.</p>
</dd>
<dt class="label" id="id2645"><span class="brackets"><a class="fn-backref" href="#id24">FFK97</a></span></dt>
<dd><p>Francisco Facchinei, Andreas Fischer, and Christian Kanzow. A semismooth Newton method for variational inequalities: The case of box constraints. <em>Complementarity and Variational Problems: State of the Art</em>, 92:76, 1997.</p>
</dd>
<dt class="label" id="id2688"><span class="brackets"><a class="fn-backref" href="#id19">FP97</a></span></dt>
<dd><p>M. C. Ferris and J. S. Pang. Engineering and economic applications of complementarity problems. <em>SIAM Review</em>, 39:669–713, 1997. URL: <a class="reference external" href="http: //www.siam.org/journals/sirev/39-4/28596.html">http: //www.siam.org/journals/sirev/39-4/28596.html</a>.</p>
</dd>
<dt class="label" id="id2721"><span class="brackets"><a class="fn-backref" href="#id25">Fis92</a></span></dt>
<dd><p>A. Fischer. A special Newton–type optimization method. <em>Optimization</em>, 24:269–284, 1992.</p>
</dd>
<dt class="label" id="id2852"><span class="brackets"><a class="fn-backref" href="#id31">GLL86</a></span></dt>
<dd><p>L. Grippo, F. Lampariello, and S. Lucidi. A nonmonotone line search technique for Newton's method. <em>SIAM Journal on Numerical Analysis</em>, 23:707–716, 1986.</p>
</dd>
<dt class="label" id="id3785"><span class="brackets"><a class="fn-backref" href="#id8">Hes69</a></span></dt>
<dd><p>Magnus R Hestenes. Multiplier and gradient methods. <em>Journal of optimization theory and applications</em>, 4(5):303–320, 1969.</p>
</dd>
<dt class="label" id="id2929"><span class="brackets"><a class="fn-backref" href="#id21">HP98</a></span></dt>
<dd><p>J. Huang and J. S. Pang. Option pricing and linear complementarity. <em>Journal of Computational Finance</em>, 2:31–60, 1998.</p>
</dd>
<dt class="label" id="id3000"><span class="brackets"><a class="fn-backref" href="#id17">Kar39</a></span></dt>
<dd><p>W. Karush. Minima of functions of several variables with inequalities as side conditions. Master's thesis, Department of Mathematics, University of Chicago, 1939.</p>
</dd>
<dt class="label" id="id3056"><span class="brackets"><a class="fn-backref" href="#id18">KT51</a></span></dt>
<dd><p>H. W. Kuhn and A. W. Tucker. Nonlinear programming. In J. Neyman, editor, <em>Proceedings of the Second Berkeley Symposium on Mathematical Statistics and Probability</em>, pages 481–492. University of California Press, Berkeley and Los Angeles, 1951.</p>
</dd>
<dt class="label" id="id2190"><span class="brackets"><a class="fn-backref" href="#id34">LMore99</a></span></dt>
<dd><p>C.-J. Lin and J. J. Moré. Newton's method for large bound-constrained optimization problems. <em>SIOPT</em>, 9(4):1100–1127, 1999. URL: <a class="reference external" href="http://www.mcs.anl.gov/home/more/papers/nb.ps.gz">http://www.mcs.anl.gov/home/more/papers/nb.ps.gz</a>.</p>
</dd>
<dt class="label" id="id3252"><span class="brackets"><a class="fn-backref" href="#id26">Mif77</a></span></dt>
<dd><p>R. Mifflin. Semismooth and semiconvex functions in constrained optimization. <em>SIAM Journal on Control and Optimization</em>, 15:957–972, 1977.</p>
</dd>
<dt class="label" id="id2188"><span class="brackets"><a class="fn-backref" href="#id32">MoreT91</a></span></dt>
<dd><p>Jorge J. Moré and G. Toraldo. On the solution of large quadratic programming problems with bound constraints. <em>SIOPT</em>, 1:93–113, 1991.</p>
</dd>
<dt class="label" id="id2187"><span class="brackets"><a class="fn-backref" href="#id35">MoreT92</a></span></dt>
<dd><p>Jorge J. Moré and David Thuente. Line search algorithms with guaranteed sufficient decrease. Technical Report MCS-P330-1092, Mathematics and Computer Science Division, Argonne National Laboratory, 1992.</p>
</dd>
<dt class="label" id="id3289"><span class="brackets"><a class="fn-backref" href="#id22">MFF+01</a></span></dt>
<dd><p>T. S. Munson, F. Facchinei, M. C. Ferris, A. Fischer, and C. Kanzow. The semismooth algorithm for large scale complementarity problems. <em>INFORMS Journal on Computing</em>, 2001.</p>
</dd>
<dt class="label" id="id3302"><span class="brackets"><a class="fn-backref" href="#id20">Nas50</a></span></dt>
<dd><p>J. F. Nash. Equilibrium points in N–person games. <em>Proceedings of the National Academy of Sciences</em>, 36:48–49, 1950.</p>
</dd>
<dt class="label" id="id3307"><span class="brackets"><a class="fn-backref" href="#id5">NM65</a></span></dt>
<dd><p>J. A. Nelder and R. Mead. A simplex method for function minimization. <em>Computer Journal</em>, 7:308–313, 1965.</p>
</dd>
<dt class="label" id="id2185"><span class="brackets"><a class="fn-backref" href="#id4">NW99</a></span></dt>
<dd><p>Jorge Nocedal and Stephen J. Wright. <em>Numerical Optimization</em>. Springer-Verlag, New York, 1999.</p>
</dd>
<dt class="label" id="id3786"><span class="brackets"><a class="fn-backref" href="#id9">Pow69</a></span></dt>
<dd><p>Michael JD Powell. A method for nonlinear constraints in minimization problems. <em>Optimization</em>, pages 283–298, 1969.</p>
</dd>
<dt class="label" id="id3442"><span class="brackets"><a class="fn-backref" href="#id27">Qi93</a></span></dt>
<dd><p>L. Qi. Convergence analysis of some algorithms for solving nonsmooth equations. <em>Mathematics of Operations Research</em>, 18:227–244, 1993.</p>
</dd>
<dt class="label" id="id3441"><span class="brackets">QS93</span><span class="fn-backref">(<a href="#id28">1</a>,<a href="#id29">2</a>)</span></dt>
<dd><p>L. Qi and J. Sun. A nonsmooth version of Newton's method. <em>Mathematical Programming</em>, 58:353–368, 1993.</p>
</dd>
<dt class="label" id="id3788"><span class="brackets"><a class="fn-backref" href="#id10">Roc74</a></span></dt>
<dd><p>R Tyrrell Rockafellar. Augmented lagrange multiplier functions and duality in nonconvex programming. <em>SIAM Journal on Control</em>, 12(2):268–285, 1974.</p>
</dd>
<dt class="label" id="id2556"><span class="brackets"><a class="fn-backref" href="#id23">DeLucaFK96</a></span></dt>
<dd><p>T. De Luca, F. Facchinei, and C. Kanzow. A semismooth equation approach to the solution of nonlinear complementarity problems. <em>Mathematical Programming</em>, 75:407–439, 1996.</p>
</dd>
<dt class="label" id="id3784"><span class="brackets"><a class="fn-backref" href="#id14">KortelainenLesinskiMore+10</a></span></dt>
<dd><p>M. Kortelainen, T. Lesinski, J. Moré, W. Nazarewicz, J. Sarich, N. Schunck, M. V. Stoitsov, and S. M. Wild. Nuclear energy density optimization. <em>Physical Review C</em>, 82(2):024313, 2010. <a class="reference external" href="https://doi.org/10.1103/PhysRevC.82.024313">doi:10.1103/PhysRevC.82.024313</a>.</p>
</dd>
</dl>
</div>
</section>
</section>
</section>
</section>


            </article>
            
            
            
            <footer class="bd-footer-article">
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="ts.html" title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">TS: Scalable ODE and DAE Solvers</p>
      </div>
  </a>
  <a class='right-next' id="next-link" href="dm.html" title="next page">
  <div class="prev-next-info">
      <p class="prev-next-subtitle">next</p>
      <p class="prev-next-title">DM: Interfacing Between Solvers and Models/Discretizations</p>
  </div>
  <i class="fa-solid fa-angle-right"></i>
  </a>
</div>
            </footer>
            
          </div>
          
          
          
            <div class="bd-sidebar-secondary bd-toc">
              
<div class="toc-item">
  
<div class="tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
</div>
<nav id="bd-toc-nav" class="page-toc">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#getting-started-a-simple-tao-example">
   Getting Started: A Simple TAO Example
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tao-workflow">
   TAO Workflow
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#header-file">
     Header File
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#creation-and-destruction">
     Creation and Destruction
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#command-line-options">
     Command-line Options
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#defining-variables">
     Defining Variables
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#user-defined-call-back-routines">
     User Defined Call-back Routines
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#application-context">
       Application Context
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#objective-function-and-gradient-routines">
       Objective Function and Gradient Routines
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#hessian-evaluation">
       Hessian Evaluation
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#finite-differences">
         Finite Differences
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#matrix-free-methods">
         Matrix-Free Methods
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#constraints">
       Constraints
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#variable-bounds">
         Variable Bounds
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#general-constraints">
         General Constraints
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#solving">
     Solving
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#convergence">
       Convergence
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#viewing-status">
       Viewing Status
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#obtaining-a-solution">
       Obtaining a Solution
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#special-problem-structures">
     Special Problem structures
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pde-constrained-optimization">
       PDE-constrained Optimization
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#nonlinear-least-squares">
       Nonlinear Least Squares
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#complementarity">
       Complementarity
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#tao-algorithms">
   TAO Algorithms
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unconstrained-minimization">
     Unconstrained Minimization
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#newton-krylov-methods">
       Newton-Krylov Methods
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#newton-line-search-method-nls">
         Newton Line Search Method (NLS)
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#newton-trust-region-method-ntr">
         Newton Trust-Region Method (NTR)
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#newton-trust-region-with-line-search-ntl">
         Newton Trust Region with Line Search (NTL)
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#limited-memory-variable-metric-method-lmvm">
       Limited-Memory Variable-Metric Method (LMVM)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#nonlinear-conjugate-gradient-method-cg">
       Nonlinear Conjugate Gradient Method (CG)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#nelder-mead-simplex-method-nm">
       Nelder-Mead Simplex Method (NM)
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#bound-constrained-optimization">
     Bound-Constrained Optimization
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bounded-newton-krylov-methods">
       Bounded Newton-Krylov Methods
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#bounded-newton-line-search-bnls">
         Bounded Newton Line Search (BNLS)
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#bounded-newton-trust-region-bntr">
         Bounded Newton Trust Region (BNTR)
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#bounded-newton-trust-region-with-line-search-bntl">
         Bounded Newton Trust Region with Line Search (BNTL)
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bounded-quasi-newton-line-search-bqnls">
       Bounded Quasi-Newton Line Search (BQNLS)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bounded-quasi-newton-krylov">
       Bounded Quasi-Newton-Krylov
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bounded-nonlinear-conjugate-gradient-bncg">
       Bounded Nonlinear Conjugate Gradient (BNCG)
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#generally-constrained-solvers">
     Generally Constrained Solvers
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#alternating-direction-method-of-multipliers-admm">
       Alternating Direction Method of Multipliers (ADMM)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#augmented-lagrangian-method-of-multipliers-almm">
       Augmented Lagrangian Method of Multipliers (ALMM)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#primal-dual-interior-point-method-pdipm">
       Primal-Dual Interior-Point Method (PDIPM)
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id11">
     PDE-Constrained Optimization
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#linearly-constrained-augmented-lagrangian-method-lcl">
       Linearly-Constrained Augmented Lagrangian Method (LCL)
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#newton-step">
         Newton Step
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#modified-reduced-space-step">
         Modified Reduced-Space Step
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sec-leastsquares">
     Nonlinear Least-Squares
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bound-constrained-regularized-gauss-newton-brgn">
       Bound-constrained Regularized Gauss-Newton (BRGN)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pounders">
       POUNDERS
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#derivative-free-trust-region-algorithm">
         Derivative-Free Trust-Region Algorithm
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#forming-the-trust-region-model">
         Forming the Trust-Region Model
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#parameters">
         Parameters
        </a>
       </li>
       <li class="toc-h5 nav-item toc-entry">
        <a class="reference internal nav-link" href="#convergence-notes">
         Convergence Notes
        </a>
       </li>
      </ul>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sec-complementarity">
     Complementarity
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#semismooth-methods">
       Semismooth Methods
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#active-set-methods">
       Active-Set Methods
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#quadratic-solvers">
     Quadratic Solvers
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#gradient-projection-conjugate-gradient-method-gpcg">
       Gradient Projection Conjugate Gradient Method (GPCG)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#interior-point-newtons-method-bqpip">
       Interior-Point Newton’s Method (BQPIP)
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#legacy-and-contributed-solvers">
     Legacy and Contributed Solvers
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bundle-method-for-regularized-risk-minimization-bmrm">
       Bundle Method for Regularized Risk Minimization (BMRM)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#orthant-wise-limited-memory-quasi-newton-owlqn">
       Orthant-Wise Limited-memory Quasi-Newton (OWLQN)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#trust-region-newton-method-tron">
       Trust-Region Newton Method (TRON)
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#bound-constrained-limited-memory-variable-metric-method-blmvm">
       Bound-constrained Limited-Memory Variable-Metric Method (BLMVM)
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#advanced-options">
   Advanced Options
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#linear-solvers">
     Linear Solvers
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#monitors">
     Monitors
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#convergence-tests">
     Convergence Tests
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#line-searches">
     Line Searches
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#recycling-history">
     Recycling History
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#adding-a-solver">
   Adding a Solver
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#header-file-1">
     Header File
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#tao-interface-with-solvers">
     TAO Interface with Solvers
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#solver-routine">
       Solver Routine
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#creation-routine">
       Creation Routine
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#destroy-routine">
       Destroy Routine
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#setup-routine">
       SetUp Routine
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#setfromoptions-routine">
       SetFromOptions Routine
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#view-routine">
       View Routine
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#registering-the-solver">
       Registering the Solver
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

</nav>
</div>

<div class="toc-item">
  
<div id="searchbox"></div>
</div>

<div class="toc-item">
  

<div class="tocsection editthispage">
    <a href="https://gitlab.com/petsc/petsc/edit/release/doc/manual/tao.rst">
        <i class="fa-solid fa-pencil"></i> Edit this page
    </a>
</div>

</div>

<div class="toc-item">
  
<div class="tocsection sourcelink">
    <a href="../_sources/manual/tao.rst.txt">
        <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
</div>

</div>

            </div>
          
          
        </div>
        <footer class="bd-footer-content">
          <div class="bd-footer-content__inner">
            
          </div>
        </footer>
        
      </main>
    </div>
  </div>

  
    
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94"></script>

  <footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 1991-2023, UChicago Argonne, LLC and the PETSc Development Team.<br>

</p>

  </div>
  
  <div class="footer-item">
    
<p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.3.0.<br>
</p>

  </div>
  
  <div class="footer-item">
    <p class="last-updated">
Last updated on 2023-04-30T09:17:39-0500 (v3.19.1).<br>
</p>
  </div>
  
</div>
  </footer>
  </body>
</html>