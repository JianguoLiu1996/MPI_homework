:orphan:
# TSSetRHSHessianProduct
Sets the function that computes the vector-Hessian-vector product. The Hessian is the second-order derivative of G (RHSFunction) w.r.t. the state variable. 
## Synopsis
```
#include "petscts.h"  
PetscErrorCode TSSetRHSHessianProduct(TS ts, Vec *rhshp1, PetscErrorCode (*rhshessianproductfunc1)(TS, PetscReal, Vec, Vec *, Vec, Vec *, void *), Vec *rhshp2, PetscErrorCode (*rhshessianproductfunc2)(TS, PetscReal, Vec, Vec *, Vec, Vec *, void *), Vec *rhshp3, PetscErrorCode (*rhshessianproductfunc3)(TS, PetscReal, Vec, Vec *, Vec, Vec *, void *), Vec *rhshp4, PetscErrorCode (*rhshessianproductfunc4)(TS, PetscReal, Vec, Vec *, Vec, Vec *, void *), void *ctx)
```
Logically Collective


## Input Parameters

- ***ts -*** `TS` context obtained from `TSCreate()`
- ***rhshp1 -*** an array of vectors storing the result of vector-Hessian-vector product for G_UU
- ***hessianproductfunc1 -*** vector-Hessian-vector product function for G_UU
- ***rhshp2 -*** an array of vectors storing the result of vector-Hessian-vector product for G_UP
- ***hessianproductfunc2 -*** vector-Hessian-vector product function for G_UP
- ***rhshp3 -*** an array of vectors storing the result of vector-Hessian-vector product for G_PU
- ***hessianproductfunc3 -*** vector-Hessian-vector product function for G_PU
- ***rhshp4 -*** an array of vectors storing the result of vector-Hessian-vector product for G_PP
- ***hessianproductfunc4 -*** vector-Hessian-vector product function for G_PP



## Calling sequence of `ihessianproductfunc`
```none
PetscErrorCode rhshessianproductfunc(TS ts, PetscReal t, Vec U, Vec *Vl, Vec Vr, Vec *VHV, void *ctx);
```

- ***t -*** current timestep
- ***U -*** input vector (current ODE solution)
- ***Vl -*** an array of input vectors to be left-multiplied with the Hessian
- ***Vr -*** input vector to be right-multiplied with the Hessian
- ***VHV -*** an array of output vectors for vector-Hessian-vector product
- ***ctx -*** [optional] user-defined function context





## Notes
The first Hessian function and the working array are required.
As an example to implement the callback functions, the second callback function calculates the vector-Hessian-vector product
$ Vl_n^T*G_UP*Vr
where the vector Vl_n (n-th element in the array Vl) and Vr are of size N and M respectively, and the Hessian G_UP is of size N x N x M.
Each entry of G_UP corresponds to the derivative
$ G_UP[i][j][k] = \frac{\partial^2 G[i]}{\partial U[j] \partial P[k]}.
The result of the vector-Hessian-vector product for Vl_n needs to be stored in vector VHV_n with j-th entry being
$ VHV_n[j] = \sum_i \sum_k {Vl_n[i] * G_UP[i][j][k] * Vr[k]}
If the cost function is a scalar, there will be only one vector in Vl and VHV.


## See Also
 `TS`, `TSAdjoint`

## Level
intermediate

## Location
<A HREF="PETSC_DOC_OUT_ROOT_PLACEHOLDER/src/ts/interface/sensitivity/tssen.c.html#TSSetRHSHessianProduct">src/ts/interface/sensitivity/tssen.c</A>

## Examples
<A HREF="PETSC_DOC_OUT_ROOT_PLACEHOLDER/src/ts/tutorials/ex20opt_ic.c.html">src/ts/tutorials/ex20opt_ic.c</A><BR>
<A HREF="PETSC_DOC_OUT_ROOT_PLACEHOLDER/src/ts/tutorials/ex20opt_p.c.html">src/ts/tutorials/ex20opt_p.c</A><BR>


---
[Edit on GitLab](https://gitlab.com/petsc/petsc/-/edit/release/src/ts/interface/sensitivity/tssen.c)


[Index of all Sensitivity routines](index.md)  
[Table of Contents for all manual pages](/manualpages/index.md)  
[Index of all manual pages](/manualpages/singleindex.md)  
